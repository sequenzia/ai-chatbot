{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AI Chatbot Developer Documentation","text":"<p>Welcome to the AI Chatbot developer documentation. This guide will help you understand the architecture, contribute to the codebase, and extend the application with new features.</p>"},{"location":"#overview","title":"Overview","text":"<p>This is a modular monolith AI chatbot application built with modern technologies:</p> Category Technology Version Framework Next.js 15.0.0 React React 18.3.1 AI Vercel AI SDK 6.0.12 AI Provider @ai-sdk/openai 3.0.21 AI Search @tavily/core 0.6.4 Database Dexie (IndexedDB) 4.2.1 Styling Tailwind CSS 4.0.0 Animation Framer Motion 12.23.24 Forms react-hook-form 7.55.0 Validation Zod 3.23.0 Charts recharts 2.15.2 Code Syntax shiki 3.20.0"},{"location":"#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Client-server split: React components handle UI, Next.js API routes handle AI interactions</li> <li>Provider pattern: State management via <code>ChatProvider</code> and <code>ThemeProvider</code></li> <li>Tool-based AI architecture: 5 interactive tools (forms, charts, code, cards, web search)</li> <li>Local-first persistence: IndexedDB via Dexie with delayed conversation creation</li> <li>Flexible deployment: Full-stack or frontend-only (via <code>NEXT_PUBLIC_CHAT_API_URL</code>)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Clone the repository\ngit clone https://github.com/sequenzia/ai-chatbot.git\ncd ai-chatbot\n\n# Install dependencies\nnpm install\n\n# Set up environment variables\ncp .env.example .env.local\n# Edit .env.local with your API keys\n\n# Start development server\nnpm run dev\n</code></pre> <p>Then open http://localhost:3000 in your browser.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p> Architecture</p> <p>Understand the high-level architecture, module dependencies, and design decisions.</p> <p> Architecture Overview</p> </li> <li> <p> Getting Started</p> <p>Set up your development environment and learn the project structure.</p> <p> Getting Started</p> </li> <li> <p> Modules</p> <p>Deep dive into each module: chat system, AI integration, rendering blocks, and persistence.</p> <p> Module Documentation</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for common tasks like adding new AI tools.</p> <p> Tutorials</p> </li> <li> <p> Reference</p> <p>API documentation and component reference.</p> <p> Reference</p> </li> </ul>"},{"location":"#entry-points","title":"Entry Points","text":"<p>When exploring the codebase, start with these key files:</p> File Purpose <code>src/app/page.tsx</code> Main chat UI entry point <code>src/app/api/chat/route.ts</code> Streaming AI endpoint <code>src/components/chat/ChatProvider.tsx</code> Central state management <code>src/lib/ai/tools.ts</code> AI tool definitions <code>src/lib/db/schema.ts</code> Database schema"},{"location":"#environment-variables","title":"Environment Variables","text":"<pre><code># Required\nOPENAI_API_KEY=your_openai_api_key_here\n\n# Optional - enables web search tool\nTAVILY_API_KEY=your_tavily_api_key_here\n\n# Optional - custom backend URL\nNEXT_PUBLIC_CHAT_API_URL=https://api.example.com\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<ol> <li>Read the Architecture Overview to understand the codebase</li> <li>Follow the Getting Started guide to set up your environment</li> <li>Check the Tutorials for guidance on common tasks</li> <li>Use the Reference for API and component details</li> </ol>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of the AI Chatbot application architecture, including the dependency graph, module responsibilities, and key design decisions.</p>"},{"location":"architecture/#high-level-architecture","title":"High-Level Architecture","text":"<p>The application follows a modular monolith architecture with clear separation between:</p> <ul> <li>Presentation Layer: React components with AI SDK UI elements</li> <li>State Management: Context providers and custom hooks</li> <li>AI Integration: Model factory, tools, and streaming</li> <li>Persistence: IndexedDB via Dexie</li> </ul> <pre><code>graph TB\n    subgraph Presentation[\"Presentation Layer\"]\n        Page[page.tsx]\n        ChatConv[ChatConversation]\n        ChatInput[ChatInput]\n        Sidebar[Sidebar]\n        Blocks[Content Blocks]\n    end\n\n    subgraph State[\"State Management\"]\n        ChatProvider[ChatProvider]\n        ThemeProvider[ThemeProvider]\n    end\n\n    subgraph Hooks[\"Custom Hooks\"]\n        usePersist[useChatPersistence]\n        useConv[useConversations]\n        useTitle[useTitleGeneration]\n    end\n\n    subgraph AI[\"AI Integration\"]\n        APIChat[\"/api/chat\"]\n        APITitle[\"/api/generate-title\"]\n        Model[getModel]\n        Tools[AI Tools]\n        Prompts[System Prompts]\n    end\n\n    subgraph Data[\"Data Layer\"]\n        Dexie[Dexie Database]\n        IndexedDB[(IndexedDB)]\n    end\n\n    subgraph External[\"External Services\"]\n        OpenAI[OpenAI API]\n        Tavily[Tavily API]\n    end\n\n    Page --&gt; ChatProvider\n    ChatProvider --&gt; ChatConv\n    ChatProvider --&gt; ChatInput\n    Page --&gt; Sidebar\n\n    ChatProvider --&gt; usePersist\n    ChatProvider --&gt; useTitle\n    Sidebar --&gt; useConv\n\n    ChatProvider -.-&gt;|HTTP Stream| APIChat\n    useTitle -.-&gt;|HTTP| APITitle\n\n    APIChat --&gt; Model\n    APIChat --&gt; Tools\n    APIChat --&gt; Prompts\n    APITitle --&gt; Model\n\n    usePersist --&gt; Dexie\n    useConv --&gt; Dexie\n    Dexie --&gt; IndexedDB\n\n    Model --&gt; OpenAI\n    Tools --&gt; Tavily\n\n    ChatConv --&gt; Blocks</code></pre>"},{"location":"architecture/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"architecture/#presentation-layer","title":"Presentation Layer","text":"Module Location Responsibility page.tsx <code>src/app/page.tsx</code> Main entry point, renders WelcomeScreen or ChatConversation ChatConversation <code>src/components/chat/ChatConversation.tsx</code> Message list with auto-scroll ChatMessageItem <code>src/components/chat/ChatMessageItem.tsx</code> Individual message rendering, tool result routing ChatInput <code>src/components/chat/ChatInput.tsx</code> Input composer with model selector Sidebar <code>src/components/layout/Sidebar.tsx</code> Navigation, conversation list, settings Content Blocks <code>src/components/blocks/</code> Form, Chart, Code, Card renderers"},{"location":"architecture/#state-management","title":"State Management","text":"Module Location Responsibility ChatProvider <code>src/components/chat/ChatProvider.tsx</code> Central context for chat state, AI SDK integration, persistence orchestration ThemeProvider <code>src/components/providers/ThemeProvider.tsx</code> Dark/light mode management"},{"location":"architecture/#custom-hooks","title":"Custom Hooks","text":"Hook Location Responsibility useChatPersistence <code>src/hooks/useChatPersistence.ts</code> Message save/load, delayed conversation creation useConversations <code>src/hooks/useConversations.ts</code> Conversation list CRUD operations useTitleGeneration <code>src/hooks/useTitleGeneration.ts</code> LLM title generation with retry logic"},{"location":"architecture/#ai-integration","title":"AI Integration","text":"Module Location Responsibility /api/chat <code>src/app/api/chat/route.ts</code> Streaming chat endpoint, tool execution /api/generate-title <code>src/app/api/generate-title/route.ts</code> Title generation endpoint getModel <code>src/lib/ai/model.ts</code> Model factory with middleware support tools <code>src/lib/ai/tools.ts</code> 5 AI tool definitions prompts <code>src/lib/ai/prompts.ts</code> System prompts with tool guidance"},{"location":"architecture/#data-layer","title":"Data Layer","text":"Module Location Responsibility Dexie Schema <code>src/lib/db/schema.ts</code> Database tables and indexes Types <code>src/lib/db/types.ts</code> TypeScript interfaces for records"},{"location":"architecture/#dependency-graph","title":"Dependency Graph","text":"<pre><code>graph LR\n    subgraph Entry[\"Entry Point\"]\n        Page[page.tsx]\n    end\n\n    subgraph Provider[\"Context\"]\n        CP[ChatProvider]\n    end\n\n    subgraph Hooks[\"Hooks Layer\"]\n        UCP[useChatPersistence]\n        UTG[useTitleGeneration]\n        UC[useConversations]\n    end\n\n    subgraph DB[\"Database\"]\n        Dexie[Dexie]\n    end\n\n    subgraph API[\"API Routes\"]\n        Chat[\"/api/chat\"]\n        Title[\"/api/generate-title\"]\n    end\n\n    subgraph AILib[\"AI Library\"]\n        Model[getModel]\n        Tools[tools]\n        Prompts[prompts]\n    end\n\n    subgraph Config[\"Configuration\"]\n        Cfg[config.ts]\n    end\n\n    subgraph External[\"External\"]\n        OpenAI[OpenAI]\n        Tavily[Tavily]\n    end\n\n    Page --&gt; CP\n    CP --&gt; UCP\n    CP --&gt; UTG\n    CP --&gt; UC\n\n    UCP --&gt; Dexie\n    UC --&gt; Dexie\n\n    CP -.-&gt; Chat\n    UTG -.-&gt; Title\n\n    Chat --&gt; Model\n    Chat --&gt; Tools\n    Chat --&gt; Prompts\n    Title --&gt; Model\n\n    Model --&gt; Cfg\n    Tools --&gt; Cfg\n\n    Model --&gt; OpenAI\n    Tools --&gt; Tavily</code></pre>"},{"location":"architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"architecture/#1-provider-pattern-for-state-management","title":"1. Provider Pattern for State Management","text":"<p>Decision: Use React Context via <code>ChatProvider</code> instead of external state management libraries.</p> <p>Rationale:</p> <ul> <li>AI SDK's <code>useChat</code> hook provides most state management out of the box</li> <li>Single provider simplifies state coordination between chat, persistence, and title generation</li> <li>No additional dependencies (Redux, Zustand, etc.)</li> </ul> <p>Trade-offs:</p> <ul> <li>Re-renders propagate to all consumers (acceptable for chat UI)</li> <li>Cannot easily share state across multiple provider instances</li> </ul>"},{"location":"architecture/#2-local-first-with-indexeddb","title":"2. Local-First with IndexedDB","text":"<p>Decision: Store conversations and messages in IndexedDB via Dexie instead of a backend database.</p> <p>Rationale:</p> <ul> <li>Works offline</li> <li>No server infrastructure required for persistence</li> <li>Instant data access</li> <li>User owns their data</li> </ul> <p>Trade-offs:</p> <ul> <li>Data lost if browser storage is cleared</li> <li>No cross-device sync (would require additional backend)</li> <li>Storage limits vary by browser (~1GB Safari, ~60% disk Chrome)</li> </ul>"},{"location":"architecture/#3-delayed-conversation-creation","title":"3. Delayed Conversation Creation","text":"<p>Decision: Only create conversation records in the database after the first message is sent.</p> <p>Rationale:</p> <ul> <li>Prevents orphan conversations when users open the app but don't chat</li> <li>All conversations in the database have at least one message</li> <li>Simplifies UI logic (no empty state handling)</li> </ul> <p>Implementation: See Persistence Module.</p>"},{"location":"architecture/#4-tool-based-ai-architecture","title":"4. Tool-Based AI Architecture","text":"<p>Decision: Implement interactive content (forms, charts, code blocks) as AI tools rather than markdown parsing.</p> <p>Rationale:</p> <ul> <li>Type-safe data structures via Zod schemas</li> <li>Clear separation between tool definition and rendering</li> <li>AI can choose appropriate tool based on user intent</li> <li>Easily extensible (add new tools without changing rendering logic)</li> </ul> <p>Trade-offs:</p> <ul> <li>Requires system prompt guidance for tool selection</li> <li>More complex than simple markdown rendering</li> </ul>"},{"location":"architecture/#5-discriminated-unions-for-content-blocks","title":"5. Discriminated Unions for Content Blocks","text":"<p>Decision: Use TypeScript discriminated unions with Zod validation for tool outputs.</p> <p>Rationale:</p> <ul> <li>Compile-time type safety</li> <li>Runtime validation prevents invalid data</li> <li>Exhaustive switch cases catch missing block types</li> <li>Self-documenting code</li> </ul> <p>Example:</p> <pre><code>type ContentBlock =\n  | { type: \"form\"; ... }\n  | { type: \"chart\"; ... }\n  | { type: \"code\"; ... }\n  | { type: \"card\"; ... };\n</code></pre>"},{"location":"architecture/#6-streaming-responses","title":"6. Streaming Responses","text":"<p>Decision: Use AI SDK's streaming capabilities for real-time response rendering.</p> <p>Rationale:</p> <ul> <li>Better perceived performance</li> <li>Users see content as it's generated</li> <li>Can stop generation mid-stream</li> </ul> <p>Implementation: <code>streamText()</code> + <code>toUIMessageStreamResponse()</code> in API route.</p>"},{"location":"architecture/#7-factory-pattern-for-models","title":"7. Factory Pattern for Models","text":"<p>Decision: Use <code>getModel()</code> factory function instead of direct model instantiation.</p> <p>Rationale:</p> <ul> <li>Centralized model configuration</li> <li>Easy to add middleware (DevTools in development)</li> <li>Validates model IDs against catalog</li> <li>Switches API mode based on model capabilities</li> </ul>"},{"location":"architecture/#architecture-strengths","title":"Architecture Strengths","text":"<ol> <li>Clear Module Boundaries: Chat, AI, persistence, and UI are well-isolated</li> <li>Type Safety: TypeScript + Zod throughout the stack</li> <li>Extensibility: Adding new tools follows a clear pattern</li> <li>Performance: Streaming responses, lazy initialization</li> <li>Resilience: Retry logic, fallback titles, transaction safety</li> </ol>"},{"location":"architecture/#areas-for-improvement","title":"Areas for Improvement","text":"<ol> <li>Error Boundaries: No React error boundaries around components</li> <li>Test Coverage: No automated tests</li> <li>Pagination: All messages loaded at once for a conversation</li> <li>Storage Monitoring: No warning when approaching IndexedDB limits</li> </ol> <p>See Modules for detailed documentation of each system.</p>"},{"location":"architecture/data-flow/","title":"Data Flow","text":"<p>This document describes how data flows through the application for common operations.</p>"},{"location":"architecture/data-flow/#message-lifecycle","title":"Message Lifecycle","text":"<p>The complete flow from user input to persisted message:</p> <pre><code>sequenceDiagram\n    participant User\n    participant ChatInput\n    participant ChatProvider\n    participant Transport as DefaultChatTransport\n    participant API as /api/chat\n    participant OpenAI\n    participant UI as ChatMessageItem\n    participant Persistence as useChatPersistence\n    participant DB as IndexedDB\n\n    User-&gt;&gt;ChatInput: Types message\n    ChatInput-&gt;&gt;ChatProvider: sendMessage(text)\n    ChatProvider-&gt;&gt;ChatProvider: Validate text.trim()\n    ChatProvider-&gt;&gt;Transport: POST /api/chat\n\n    Transport-&gt;&gt;API: { messages, model }\n    API-&gt;&gt;API: getModel(model)\n    API-&gt;&gt;API: Convert UIMessages\n    API-&gt;&gt;OpenAI: streamText()\n\n    loop Streaming\n        OpenAI--&gt;&gt;API: Token chunks\n        API--&gt;&gt;Transport: Stream response\n        Transport--&gt;&gt;ChatProvider: Update messages\n        ChatProvider--&gt;&gt;UI: Re-render\n    end\n\n    OpenAI-&gt;&gt;API: Stream complete\n    API-&gt;&gt;Transport: Close stream\n    Transport-&gt;&gt;ChatProvider: status = 'ready'\n\n    ChatProvider-&gt;&gt;Persistence: saveMessage(userMsg)\n    ChatProvider-&gt;&gt;Persistence: saveMessage(assistantMsg)\n    Persistence-&gt;&gt;DB: Transaction: Insert messages\n\n    Note over ChatProvider: After first exchange\n    ChatProvider-&gt;&gt;ChatProvider: generateTitle()</code></pre>"},{"location":"architecture/data-flow/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":""},{"location":"architecture/data-flow/#1-user-input","title":"1. User Input","text":"<pre><code>// ChatInput.tsx\nconst handleSubmit = () =&gt; {\n  if (text.trim()) {\n    sendMessage(text);\n    setText('');\n  }\n};\n</code></pre>"},{"location":"architecture/data-flow/#2-context-provider","title":"2. Context Provider","text":"<pre><code>// ChatProvider.tsx\nconst sendMessage = useCallback((text: string) =&gt; {\n  if (!text.trim()) return;\n  chat.sendMessage({ text });\n}, [chat]);\n</code></pre>"},{"location":"architecture/data-flow/#3-api-route","title":"3. API Route","text":"<pre><code>// /api/chat/route.ts\nexport async function POST(request: Request) {\n  const { messages, model: selectedModel } = await request.json();\n\n  const result = streamText({\n    model: getModel(selectedModel),\n    system: SYSTEM_PROMPT,\n    messages: convertToModelMessages(messages),\n    tools: chatTools,\n    stopWhen: stepCountIs(3),\n  });\n\n  return result.toUIMessageStreamResponse();\n}\n</code></pre>"},{"location":"architecture/data-flow/#4-persistence","title":"4. Persistence","text":"<pre><code>// ChatProvider.tsx useEffect\nif (status === 'ready') {\n  const newMessages = messages.filter(m =&gt; !previousIds.has(m.id));\n  for (const message of newMessages) {\n    await saveMessage(message, fallbackTitle);\n  }\n}\n</code></pre>"},{"location":"architecture/data-flow/#tool-execution-flow","title":"Tool Execution Flow","text":"<p>When the AI decides to use a tool:</p> <pre><code>sequenceDiagram\n    participant AI as OpenAI\n    participant API as /api/chat\n    participant Tool as Tool Handler\n    participant Stream\n    participant UI as ChatMessageItem\n    participant Block as ContentBlock\n\n    AI-&gt;&gt;API: tool_call (generateChart)\n    API-&gt;&gt;Tool: Validate with Zod\n    Tool-&gt;&gt;Tool: execute(params)\n    Tool--&gt;&gt;API: { type: 'chart', data: [...] }\n\n    API-&gt;&gt;Stream: tool-generateChart part\n    Stream-&gt;&gt;UI: Update message.parts\n\n    UI-&gt;&gt;UI: Detect tool- prefix\n    UI-&gt;&gt;UI: Check CONTENT_BLOCK_TOOLS\n    UI-&gt;&gt;Block: Render ContentBlock\n\n    Block-&gt;&gt;Block: Switch on content.type\n    Block-&gt;&gt;Block: Render ChartContent</code></pre>"},{"location":"architecture/data-flow/#tool-execution-code","title":"Tool Execution Code","text":"<pre><code>// src/lib/ai/tools.ts\nexport const generateChart = tool&lt;ChartContentData, ChartContentData&gt;({\n  description: \"Generate a data visualization chart\",\n  inputSchema: ChartContentDataSchema,\n  execute: async (input) =&gt; input, // Pass-through pattern\n});\n</code></pre>"},{"location":"architecture/data-flow/#tool-result-rendering","title":"Tool Result Rendering","text":"<pre><code>// ChatMessageItem.tsx\nconst CONTENT_BLOCK_TOOLS = [\n  'generateForm',\n  'generateChart',\n  'generateCode',\n  'generateCard',\n];\n\n// In render\nif (part.type.startsWith('tool-')) {\n  const toolName = part.type.replace('tool-', '');\n  if (CONTENT_BLOCK_TOOLS.includes(toolName)) {\n    if (toolPart.state === 'output-available') {\n      return &lt;ContentBlock content={toolPart.output} /&gt;;\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/data-flow/#persistence-flow","title":"Persistence Flow","text":"<p>How messages are saved to IndexedDB:</p> <pre><code>sequenceDiagram\n    participant Provider as ChatProvider\n    participant Hook as useChatPersistence\n    participant Dexie\n    participant DB as IndexedDB\n\n    Provider-&gt;&gt;Hook: saveMessage(msg, fallbackTitle)\n\n    Hook-&gt;&gt;Hook: Check isPersistedRef\n\n    alt First message in conversation\n        Hook-&gt;&gt;Dexie: db.transaction('rw', ...)\n        Dexie-&gt;&gt;DB: Check if conversation exists\n        DB--&gt;&gt;Dexie: Not found\n        Dexie-&gt;&gt;DB: INSERT conversation\n        Note over DB: { id, title: fallbackTitle, ... }\n        Hook-&gt;&gt;Hook: isPersistedRef = true\n    end\n\n    Hook-&gt;&gt;Dexie: Check for duplicate message\n    Dexie-&gt;&gt;DB: WHERE visibleId = msg.id\n    DB--&gt;&gt;Dexie: Not found\n\n    Hook-&gt;&gt;Dexie: INSERT message\n    Note over DB: { visibleId, conversationId, content: JSON.stringify(parts) }\n\n    Hook-&gt;&gt;Dexie: UPDATE conversation.updatedAt\n    Dexie-&gt;&gt;DB: COMMIT transaction</code></pre>"},{"location":"architecture/data-flow/#delayed-conversation-creation","title":"Delayed Conversation Creation","text":"<pre><code>// useChatPersistence.ts\nconst saveMessage = useCallback(async (message, fallbackTitle) =&gt; {\n  await db.transaction('rw', db.messages, db.conversations, async () =&gt; {\n    // Only create conversation on first save\n    if (!isPersistedRef.current) {\n      const existing = await db.conversations.get(currentConversationId);\n      if (!existing) {\n        await db.conversations.put({\n          id: currentConversationId,\n          title: fallbackTitle || 'New Chat',\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n      }\n      isPersistedRef.current = true;\n    }\n\n    // Check for duplicate\n    const duplicate = await db.messages\n      .where('conversationId')\n      .equals(currentConversationId)\n      .filter(m =&gt; m.visibleId === message.id)\n      .first();\n\n    if (duplicate) return;\n\n    // Insert message\n    await db.messages.add({\n      visibleId: message.id,\n      conversationId: currentConversationId,\n      role: message.role,\n      content: JSON.stringify(message.parts),\n      createdAt: new Date(),\n    });\n\n    await db.conversations.update(currentConversationId, {\n      updatedAt: new Date(),\n    });\n  });\n}, [currentConversationId]);\n</code></pre>"},{"location":"architecture/data-flow/#conversation-switching-flow","title":"Conversation Switching Flow","text":"<p>When user clicks a conversation in the sidebar:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Sidebar\n    participant Provider as ChatProvider\n    participant Hook as useChatPersistence\n    participant DB as IndexedDB\n    participant UI as ChatConversation\n\n    User-&gt;&gt;Sidebar: Click conversation\n    Sidebar-&gt;&gt;Provider: switchConversation(id)\n\n    Provider-&gt;&gt;Provider: setMessages([])\n    Provider-&gt;&gt;Provider: hasLoadedRef = true\n    Provider-&gt;&gt;Provider: titleGeneratedRef.add(id)\n\n    Provider-&gt;&gt;Hook: switchConversationDb(id)\n    Hook-&gt;&gt;DB: Direct query (not live query)\n    DB--&gt;&gt;Hook: messages[]\n\n    Hook-&gt;&gt;Hook: Convert to UIMessages\n    Hook--&gt;&gt;Provider: UIMessage[]\n\n    Provider-&gt;&gt;Provider: setMessages(messages)\n    Provider-&gt;&gt;Provider: previousMessagesRef = messages\n\n    Provider--&gt;&gt;UI: Re-render with new messages</code></pre>"},{"location":"architecture/data-flow/#why-direct-query","title":"Why Direct Query?","text":"<p>The <code>switchConversation</code> function uses a direct database query instead of the live query to avoid UI flicker:</p> <pre><code>// useChatPersistence.ts\nconst switchConversation = useCallback(async (id: string) =&gt; {\n  // Direct fetch bypasses live query reactivity lag\n  const records = await db.messages\n    .where('conversationId')\n    .equals(id)\n    .sortBy('createdAt');\n\n  return records.map(convertToUIMessage);\n}, []);\n</code></pre>"},{"location":"architecture/data-flow/#title-generation-flow","title":"Title Generation Flow","text":"<p>After the first user+assistant exchange:</p> <pre><code>sequenceDiagram\n    participant Provider as ChatProvider\n    participant Hook as useTitleGeneration\n    participant API as /api/generate-title\n    participant OpenAI\n    participant DB as IndexedDB\n\n    Provider-&gt;&gt;Provider: Check conditions\n    Note over Provider: hasUserMsg &amp;&amp; hasAssistantMsg &amp;&amp; !generated\n\n    Provider-&gt;&gt;Hook: generateTitle(convId, userText)\n    Hook-&gt;&gt;Hook: Check pendingRef\n    Hook-&gt;&gt;Hook: Set pendingRef = convId\n\n    loop Retry (max 3 attempts)\n        Hook-&gt;&gt;API: POST { userMessage, conversationId }\n        API-&gt;&gt;OpenAI: Generate title\n\n        alt Success\n            OpenAI--&gt;&gt;API: \"Title text\"\n            API--&gt;&gt;Hook: { title: \"Title text\" }\n            Hook-&gt;&gt;DB: updateTitle(convId, title)\n            Hook-&gt;&gt;Hook: pendingRef = null\n        else Failure\n            Hook-&gt;&gt;Hook: Wait 1s/2s/4s\n        end\n    end\n\n    alt All retries failed\n        Hook-&gt;&gt;Hook: Use fallbackTitle\n        Note over Hook: First 50 chars of user message\n    end</code></pre>"},{"location":"architecture/data-flow/#retry-logic","title":"Retry Logic","text":"<pre><code>// useTitleGeneration.ts\nconst generateTitle = async (conversationId: string, userMessage: string) =&gt; {\n  const fallbackTitle = generateFallbackTitle(userMessage);\n  let attempts = 0;\n  const maxAttempts = 3;\n  const baseDelay = 1000;\n\n  const attemptGeneration = async (): Promise&lt;string&gt; =&gt; {\n    try {\n      const response = await fetch(getApiUrl('generate-title'), {\n        method: 'POST',\n        body: JSON.stringify({ userMessage, conversationId }),\n      });\n      const data = await response.json();\n      return data.title || fallbackTitle;\n    } catch (error) {\n      attempts++;\n      if (attempts &lt; maxAttempts) {\n        // Exponential backoff: 1s, 2s, 4s\n        const delay = baseDelay * Math.pow(2, attempts - 1);\n        await new Promise(r =&gt; setTimeout(r, delay));\n        return attemptGeneration();\n      }\n      return fallbackTitle;\n    }\n  };\n\n  const title = await attemptGeneration();\n  onTitleGenerated?.(conversationId, title);\n};\n</code></pre>"},{"location":"architecture/data-flow/#live-query-updates","title":"Live Query Updates","text":"<p>How the UI stays in sync with database changes:</p> <pre><code>sequenceDiagram\n    participant Component\n    participant Hook as useLiveQuery\n    participant Dexie\n    participant DB as IndexedDB\n\n    Component-&gt;&gt;Hook: useLiveQuery(() =&gt; query)\n    Hook-&gt;&gt;Dexie: Subscribe to table\n    Dexie-&gt;&gt;DB: Initial query\n    DB--&gt;&gt;Hook: Initial data\n    Hook--&gt;&gt;Component: Render data\n\n    Note over DB: Another tab/operation modifies data\n\n    DB-&gt;&gt;Dexie: Change event\n    Dexie-&gt;&gt;Hook: Re-run query function\n    Hook-&gt;&gt;DB: Fresh query\n    DB--&gt;&gt;Hook: Updated data\n    Hook--&gt;&gt;Component: Re-render</code></pre>"},{"location":"architecture/data-flow/#live-query-example","title":"Live Query Example","text":"<pre><code>// useChatPersistence.ts\nconst storedMessages = useLiveQuery(\n  () =&gt; db.messages\n    .where('conversationId')\n    .equals(currentConversationId)\n    .sortBy('createdAt'),\n  [currentConversationId] // Dependency array\n);\n</code></pre> <p>Reactivity Lag</p> <p>Live queries have a small delay (~100ms) when data changes. For user-triggered actions like conversation switching, use direct queries for immediate feedback.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you set up your development environment and start contributing to the AI Chatbot project.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> Requirement Version Check Command Node.js 18.x or later <code>node --version</code> npm 9.x or later <code>npm --version</code> Git Any recent version <code>git --version</code> <p>You'll also need:</p> <ul> <li>An OpenAI API key for chat functionality</li> <li>(Optional) A Tavily API key for web search functionality</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"npmyarnpnpm <pre><code># Clone the repository\ngit clone https://github.com/sequenzia/ai-chatbot.git\ncd ai-chatbot\n\n# Install dependencies\nnpm install\n</code></pre> <pre><code># Clone the repository\ngit clone https://github.com/sequenzia/ai-chatbot.git\ncd ai-chatbot\n\n# Install dependencies\nyarn install\n</code></pre> <pre><code># Clone the repository\ngit clone https://github.com/sequenzia/ai-chatbot.git\ncd ai-chatbot\n\n# Install dependencies\npnpm install\n</code></pre>"},{"location":"getting-started/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env.local</code> file in the project root:</p> <pre><code>cp .env.example .env.local\n</code></pre> <p>Configure the required environment variables:</p> .env.local<pre><code># Required - OpenAI API key for chat completions\nOPENAI_API_KEY=sk-your-openai-api-key-here\n\n# Optional - Tavily API key for web search tool\nTAVILY_API_KEY=tvly-your-tavily-api-key-here\n\n# Optional - Custom backend URL (for frontend-only deployment)\n# NEXT_PUBLIC_CHAT_API_URL=https://api.example.com\n</code></pre>"},{"location":"getting-started/#getting-api-keys","title":"Getting API Keys","text":""},{"location":"getting-started/#openai-api-key","title":"OpenAI API Key","text":"<ol> <li>Go to OpenAI Platform</li> <li>Sign in or create an account</li> <li>Navigate to API Keys in the sidebar</li> <li>Click Create new secret key</li> <li>Copy the key and add it to your <code>.env.local</code></li> </ol> <p>Keep your API key secret</p> <p>Never commit your <code>.env.local</code> file or share your API key publicly.</p>"},{"location":"getting-started/#tavily-api-key-optional","title":"Tavily API Key (Optional)","text":"<ol> <li>Go to Tavily</li> <li>Sign up for an account</li> <li>Navigate to your dashboard</li> <li>Copy your API key</li> </ol>"},{"location":"getting-started/#running-the-development-server","title":"Running the Development Server","text":"<p>Start the development server with Turbopack:</p> npmyarnpnpm <pre><code>npm run dev\n</code></pre> <pre><code>yarn dev\n</code></pre> <pre><code>pnpm dev\n</code></pre> <p>Open http://localhost:3000 in your browser.</p> <p>You should see</p> <p>The welcome screen with a chat input and suggestion cards.</p>"},{"location":"getting-started/#verifying-your-setup","title":"Verifying Your Setup","text":""},{"location":"getting-started/#test-chat-functionality","title":"Test Chat Functionality","text":"<ol> <li>Type a message in the chat input</li> <li>Press Enter or click Send</li> <li>Wait for the AI response to stream in</li> </ol>"},{"location":"getting-started/#test-tool-functionality","title":"Test Tool Functionality","text":"<p>Try these prompts to test each AI tool:</p> Prompt Expected Tool \"Create a contact form\" Form block \"Show a chart of monthly sales: Jan 100, Feb 150, Mar 200\" Chart block \"Write a Python function to calculate factorial\" Code block \"Create a product card for a laptop\" Card block"},{"location":"getting-started/#test-persistence","title":"Test Persistence","text":"<ol> <li>Send a few messages</li> <li>Refresh the page</li> <li>Your conversation should be preserved in the sidebar</li> </ol>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#openai_api_key-is-not-set","title":"\"OPENAI_API_KEY is not set\"","text":"<p>Ensure your <code>.env.local</code> file exists and contains a valid API key:</p> <pre><code># Check if the file exists\ncat .env.local\n\n# Verify the key is set (don't share the output!)\ngrep OPENAI_API_KEY .env.local\n</code></pre>"},{"location":"getting-started/#module-not-found-errors","title":"\"Module not found\" errors","text":"<p>Try clearing the node_modules and reinstalling:</p> <pre><code>rm -rf node_modules\nrm -rf .next\nnpm install\n</code></pre>"},{"location":"getting-started/#port-3000-is-already-in-use","title":"Port 3000 is already in use","text":"<p>Either stop the other process or use a different port:</p> <pre><code>npm run dev -- -p 3001\n</code></pre>"},{"location":"getting-started/#indexeddb-errors-in-incognito-mode","title":"IndexedDB errors in incognito mode","text":"<p>Some browsers restrict IndexedDB in private/incognito mode. Use a regular browser window for development.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that your environment is set up:</p> <ol> <li>Project Structure - Learn how the codebase is organized</li> <li>Development Workflow - Understand the development commands and workflow</li> <li>Architecture Overview - Understand the high-level design</li> <li>Modules - Deep dive into each module</li> </ol>"},{"location":"getting-started/development/","title":"Development","text":"<p>This guide covers the development workflow, available commands, and best practices.</p>"},{"location":"getting-started/development/#available-commands","title":"Available Commands","text":""},{"location":"getting-started/development/#development_1","title":"Development","text":"<pre><code># Start development server with Turbopack (fast refresh)\nnpm run dev\n\n# Start on a specific port\nnpm run dev -- -p 3001\n</code></pre>"},{"location":"getting-started/development/#production","title":"Production","text":"<pre><code># Build for production\nnpm run build\n\n# Start production server\nnpm start\n</code></pre>"},{"location":"getting-started/development/#code-quality","title":"Code Quality","text":"<pre><code># Run ESLint\nnpm run lint\n\n# Type checking\nnpm run type-check\n</code></pre>"},{"location":"getting-started/development/#development-workflow","title":"Development Workflow","text":""},{"location":"getting-started/development/#1-start-the-dev-server","title":"1. Start the Dev Server","text":"<pre><code>npm run dev\n</code></pre> <p>The server starts at http://localhost:3000 with:</p> <ul> <li>Hot Module Replacement: Changes reflect instantly</li> <li>Turbopack: Faster builds than webpack</li> <li>Error Overlay: Errors displayed in browser</li> </ul>"},{"location":"getting-started/development/#2-make-changes","title":"2. Make Changes","text":"<p>Edit files in <code>src/</code> and see changes immediately:</p> Change Type Hot Reload? Notes Component JSX Yes Instant update CSS/Tailwind Yes Instant update API Routes Yes May need to re-trigger request Environment Variables No Restart dev server <code>tsconfig.json</code> No Restart dev server"},{"location":"getting-started/development/#3-test-your-changes","title":"3. Test Your Changes","text":""},{"location":"getting-started/development/#test-chat-functionality","title":"Test Chat Functionality","text":"<ol> <li>Open the browser</li> <li>Send messages</li> <li>Verify responses stream correctly</li> <li>Check that messages persist after refresh</li> </ol>"},{"location":"getting-started/development/#test-ai-tools","title":"Test AI Tools","text":"<p>Use these test prompts:</p> <pre><code># Test Form\nCreate a registration form with name, email, and password fields\n\n# Test Chart\nShow a bar chart with Q1: 100, Q2: 150, Q3: 200, Q4: 300\n\n# Test Code\nWrite a TypeScript function to debounce function calls\n\n# Test Card\nCreate a product card for the iPhone 15 Pro\n</code></pre>"},{"location":"getting-started/development/#4-check-for-errors","title":"4. Check for Errors","text":"<pre><code># TypeScript errors\nnpm run type-check\n\n# Linting errors\nnpm run lint\n</code></pre>"},{"location":"getting-started/development/#project-configuration","title":"Project Configuration","text":""},{"location":"getting-started/development/#typescript-tsconfigjson","title":"TypeScript (<code>tsconfig.json</code>)","text":"<p>Key settings:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/development/#tailwind-css","title":"Tailwind CSS","text":"<p>Configuration in <code>tailwind.config.ts</code>:</p> <ul> <li>Theme colors use CSS variables from <code>src/styles/theme.css</code></li> <li>Dark mode uses <code>.dark</code> class on <code>&lt;html&gt;</code></li> <li>Custom variants for interactive states</li> </ul>"},{"location":"getting-started/development/#environment-variables","title":"Environment Variables","text":"Variable Required Description <code>OPENAI_API_KEY</code> Yes OpenAI API key <code>TAVILY_API_KEY</code> No Enables web search tool <code>NEXT_PUBLIC_CHAT_API_URL</code> No Custom backend URL <code>AI_DEBUG_ON</code> No Enables DevTools middleware"},{"location":"getting-started/development/#debugging","title":"Debugging","text":""},{"location":"getting-started/development/#browser-devtools","title":"Browser DevTools","text":"<p>React DevTools: Install the React DevTools extension to inspect:</p> <ul> <li>Component hierarchy</li> <li>Props and state</li> <li>Context values</li> </ul> <p>Network Tab: Monitor API requests:</p> <ul> <li><code>/api/chat</code> - Streaming responses</li> <li><code>/api/generate-title</code> - Title generation</li> </ul>"},{"location":"getting-started/development/#indexeddb-inspection","title":"IndexedDB Inspection","text":"<p>Open DevTools \u2192 Application \u2192 IndexedDB \u2192 <code>AIChatbotDB</code>:</p> <ul> <li>conversations table: View saved conversations</li> <li>messages table: View message content</li> </ul>"},{"location":"getting-started/development/#console-logging","title":"Console Logging","text":"<p>Add temporary logs for debugging:</p> <pre><code>// In ChatProvider.tsx\nuseEffect(() =&gt; {\n  console.log('Messages updated:', messages);\n  console.log('Status:', status);\n}, [messages, status]);\n</code></pre>"},{"location":"getting-started/development/#vs-code-debugging","title":"VS Code Debugging","text":"<p>Create <code>.vscode/launch.json</code>:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Next.js: debug server-side\",\n      \"type\": \"node-terminal\",\n      \"request\": \"launch\",\n      \"command\": \"npm run dev\"\n    },\n    {\n      \"name\": \"Next.js: debug client-side\",\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"url\": \"http://localhost:3000\"\n    }\n  ]\n}\n</code></pre>"},{"location":"getting-started/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"getting-started/development/#adding-a-new-component","title":"Adding a New Component","text":"<ol> <li>Create the component file:</li> </ol> <pre><code>// src/components/feature/MyComponent.tsx\n'use client';\n\nimport { cn } from '@/lib/utils';\n\ninterface MyComponentProps {\n  className?: string;\n  children: React.ReactNode;\n}\n\nexport function MyComponent({ className, children }: MyComponentProps) {\n  return (\n    &lt;div className={cn('p-4', className)}&gt;\n      {children}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <ol> <li>Use the component:</li> </ol> <pre><code>import { MyComponent } from '@/components/feature/MyComponent';\n</code></pre>"},{"location":"getting-started/development/#adding-a-new-api-route","title":"Adding a New API Route","text":"<ol> <li>Create the route file:</li> </ol> <pre><code>// src/app/api/my-endpoint/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function POST(request: Request) {\n  const body = await request.json();\n\n  // Process request...\n\n  return NextResponse.json({ success: true });\n}\n</code></pre> <ol> <li>Call from the frontend:</li> </ol> <pre><code>const response = await fetch('/api/my-endpoint', {\n  method: 'POST',\n  body: JSON.stringify({ data: 'value' }),\n});\n</code></pre>"},{"location":"getting-started/development/#adding-a-new-hook","title":"Adding a New Hook","text":"<ol> <li>Create the hook file:</li> </ol> <pre><code>// src/hooks/useMyHook.ts\nimport { useState, useCallback } from 'react';\n\nexport function useMyHook(initialValue: string) {\n  const [value, setValue] = useState(initialValue);\n\n  const update = useCallback((newValue: string) =&gt; {\n    setValue(newValue);\n  }, []);\n\n  return { value, update };\n}\n</code></pre> <ol> <li>Use the hook:</li> </ol> <pre><code>import { useMyHook } from '@/hooks/useMyHook';\n\nfunction MyComponent() {\n  const { value, update } = useMyHook('initial');\n  // ...\n}\n</code></pre>"},{"location":"getting-started/development/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/development/#code-style","title":"Code Style","text":"<ul> <li>Use <code>'use client'</code> directive for components with hooks or state</li> <li>Prefer named exports over default exports</li> <li>Use <code>cn()</code> utility for Tailwind class merging</li> <li>Follow existing patterns in the codebase</li> </ul>"},{"location":"getting-started/development/#performance","title":"Performance","text":"<ul> <li>Use <code>useCallback</code> for functions passed as props</li> <li>Use <code>useMemo</code> for expensive computations</li> <li>Avoid creating new objects/arrays in render</li> </ul>"},{"location":"getting-started/development/#accessibility","title":"Accessibility","text":"<ul> <li>Use semantic HTML elements</li> <li>Add ARIA labels where needed</li> <li>Test with keyboard navigation</li> <li>Use <code>useReducedMotion()</code> for animation preferences</li> </ul>"},{"location":"getting-started/development/#documentation","title":"Documentation","text":""},{"location":"getting-started/development/#building-the-docs","title":"Building the Docs","text":"<pre><code># Install MkDocs\npip install mkdocs-material\n\n# Serve documentation locally\nmkdocs serve\n\n# Build static documentation\nmkdocs build\n</code></pre> <p>The docs will be available at http://localhost:8000.</p>"},{"location":"getting-started/development/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Understand the system design</li> <li>Modules - Deep dive into each module</li> <li>Tutorials - Learn by building</li> </ul>"},{"location":"getting-started/project-structure/","title":"Project Structure","text":"<p>This document explains how the codebase is organized and helps you find your way around.</p>"},{"location":"getting-started/project-structure/#directory-overview","title":"Directory Overview","text":"<pre><code>ai-chatbot/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/                    # Next.js App Router\n\u2502   \u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 chat/           # Streaming chat endpoint\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 generate-title/ # Title generation endpoint\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx          # Root layout with ThemeProvider\n\u2502   \u2502   \u2514\u2500\u2500 page.tsx            # Main chat page\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 chat/               # Core chat components\n\u2502   \u2502   \u251c\u2500\u2500 ai-elements/        # AI SDK UI wrappers\n\u2502   \u2502   \u251c\u2500\u2500 blocks/             # Interactive content blocks\n\u2502   \u2502   \u251c\u2500\u2500 layout/             # Sidebar and layout\n\u2502   \u2502   \u251c\u2500\u2500 providers/          # Context providers\n\u2502   \u2502   \u2514\u2500\u2500 ui/                 # shadcn/ui components\n\u2502   \u251c\u2500\u2500 hooks/                  # Custom React hooks\n\u2502   \u251c\u2500\u2500 lib/\n\u2502   \u2502   \u251c\u2500\u2500 ai/                 # AI model, tools, prompts\n\u2502   \u2502   \u251c\u2500\u2500 db/                 # Dexie database schema\n\u2502   \u2502   \u251c\u2500\u2500 motion/             # Animation variants\n\u2502   \u2502   \u2514\u2500\u2500 utils/              # Utility functions\n\u2502   \u251c\u2500\u2500 styles/                 # CSS files\n\u2502   \u251c\u2500\u2500 types/                  # TypeScript definitions\n\u2502   \u251c\u2500\u2500 constants/              # Static data\n\u2502   \u2514\u2500\u2500 config.ts               # Environment configuration\n\u251c\u2500\u2500 docs/                       # This documentation (MkDocs)\n\u251c\u2500\u2500 public/                     # Static assets\n\u251c\u2500\u2500 mkdocs.yml                  # Documentation config\n\u251c\u2500\u2500 package.json                # Dependencies\n\u2514\u2500\u2500 tsconfig.json               # TypeScript config\n</code></pre>"},{"location":"getting-started/project-structure/#key-directories","title":"Key Directories","text":""},{"location":"getting-started/project-structure/#srcapp-nextjs-app-router","title":"<code>src/app/</code> - Next.js App Router","text":"<p>The application entry points and API routes.</p> File Purpose <code>layout.tsx</code> Root layout, wraps app with ThemeProvider <code>page.tsx</code> Main chat page with WelcomeScreen <code>api/chat/route.ts</code> Streaming chat API endpoint <code>api/generate-title/route.ts</code> Title generation API"},{"location":"getting-started/project-structure/#srccomponents-react-components","title":"<code>src/components/</code> - React Components","text":"<p>Organized by feature and responsibility.</p>"},{"location":"getting-started/project-structure/#chat-core-chat-components","title":"<code>chat/</code> - Core Chat Components","text":"Component Lines Purpose <code>ChatProvider.tsx</code> ~235 Central context, orchestrates AI + persistence <code>ChatConversation.tsx</code> ~60 Message list with auto-scroll <code>ChatMessageItem.tsx</code> ~170 Individual message rendering <code>ChatInput.tsx</code> ~80 Input composer with model selector"},{"location":"getting-started/project-structure/#blocks-interactive-content-blocks","title":"<code>blocks/</code> - Interactive Content Blocks","text":"Component Lines Purpose <code>ContentBlock.tsx</code> ~43 Dispatcher routing to block renderers <code>FormContent.tsx</code> ~252 Interactive form renderer <code>ChartContent.tsx</code> ~100 Recharts data visualization <code>CodeContent.tsx</code> ~80 Shiki syntax-highlighted code <code>CardContent.tsx</code> ~90 Rich content cards"},{"location":"getting-started/project-structure/#ui-shadcnui-components","title":"<code>ui/</code> - shadcn/ui Components","text":"<p>Reusable UI primitives following shadcn/ui conventions:</p> <ul> <li><code>button.tsx</code> - Button with variants</li> <li><code>card.tsx</code> - Card layout components</li> <li><code>input.tsx</code> - Text input</li> <li><code>select.tsx</code> - Dropdown select</li> <li>And many more...</li> </ul>"},{"location":"getting-started/project-structure/#srchooks-custom-hooks","title":"<code>src/hooks/</code> - Custom Hooks","text":"Hook Lines Purpose <code>useChatPersistence.ts</code> ~191 Message save/load with IndexedDB <code>useConversations.ts</code> ~51 Conversation list management <code>useTitleGeneration.ts</code> ~96 LLM title generation with retry <code>useReducedMotion.ts</code> ~15 Accessibility motion preference"},{"location":"getting-started/project-structure/#srclib-shared-libraries","title":"<code>src/lib/</code> - Shared Libraries","text":""},{"location":"getting-started/project-structure/#ai-ai-integration","title":"<code>ai/</code> - AI Integration","text":"File Purpose <code>model.ts</code> Model factory with middleware <code>models.ts</code> Model catalog (GPT-5, GPT-4o variants) <code>tools.ts</code> 5 AI tool definitions <code>prompts.ts</code> System prompts <code>tavily.ts</code> Web search integration"},{"location":"getting-started/project-structure/#db-database-layer","title":"<code>db/</code> - Database Layer","text":"File Purpose <code>schema.ts</code> Dexie database class definition <code>types.ts</code> TypeScript interfaces for records <code>index.ts</code> Database singleton export"},{"location":"getting-started/project-structure/#motion-animation","title":"<code>motion/</code> - Animation","text":"File Purpose <code>variants.ts</code> Framer Motion animation definitions"},{"location":"getting-started/project-structure/#srctypes-typescript-types","title":"<code>src/types/</code> - TypeScript Types","text":"File Purpose <code>content-blocks.ts</code> Zod schemas and types for tool outputs <code>message.ts</code> Message-related type helpers"},{"location":"getting-started/project-structure/#srcconfigts-configuration","title":"<code>src/config.ts</code> - Configuration","text":"<p>Centralized environment configuration:</p> <pre><code>export const config = {\n  api: {\n    baseUrl: process.env.NEXT_PUBLIC_CHAT_API_URL || '',\n  },\n  ai: {\n    webSearch: {\n      enabled: !!process.env.TAVILY_API_KEY,\n    },\n  },\n};\n\nexport function getApiUrl(endpoint: 'chat' | 'generate-title'): string {\n  // Returns correct URL based on deployment mode\n}\n</code></pre>"},{"location":"getting-started/project-structure/#file-naming-conventions","title":"File Naming Conventions","text":"Pattern Example Used For <code>PascalCase.tsx</code> <code>ChatProvider.tsx</code> React components <code>camelCase.ts</code> <code>useChatPersistence.ts</code> Hooks, utilities <code>kebab-case.ts</code> <code>content-blocks.ts</code> Type definitions <code>index.ts</code> <code>db/index.ts</code> Module exports <code>route.ts</code> <code>api/chat/route.ts</code> Next.js API routes"},{"location":"getting-started/project-structure/#key-files-to-understand-first","title":"Key Files to Understand First","text":"<p>Start with these files when learning the codebase:</p>"},{"location":"getting-started/project-structure/#1-entry-point","title":"1. Entry Point","text":"<p><code>src/app/page.tsx</code> - Understand how the app bootstraps:</p> <ul> <li><code>ChatProvider</code> wraps everything</li> <li><code>WelcomeScreen</code> shown when no messages</li> <li><code>ChatConversation</code> + <code>ChatInput</code> for active chats</li> </ul>"},{"location":"getting-started/project-structure/#2-state-management","title":"2. State Management","text":"<p><code>src/components/chat/ChatProvider.tsx</code> - The orchestration hub:</p> <ul> <li>AI SDK integration</li> <li>Persistence coordination</li> <li>Title generation triggers</li> <li>Context API exports</li> </ul>"},{"location":"getting-started/project-structure/#3-ai-tools","title":"3. AI Tools","text":"<p><code>src/lib/ai/tools.ts</code> - How interactive content is defined:</p> <ul> <li>Zod schemas for validation</li> <li>Tool execute functions</li> <li>Conditional web search</li> </ul>"},{"location":"getting-started/project-structure/#4-content-rendering","title":"4. Content Rendering","text":"<p><code>src/components/chat/ChatMessageItem.tsx</code> - How messages are displayed:</p> <ul> <li>Text rendering with Streamdown</li> <li>Tool result detection</li> <li>Block component routing</li> </ul>"},{"location":"getting-started/project-structure/#5-persistence","title":"5. Persistence","text":"<p><code>src/hooks/useChatPersistence.ts</code> - How data is saved:</p> <ul> <li>Delayed conversation creation</li> <li>Transaction handling</li> <li>Live query integration</li> </ul>"},{"location":"getting-started/project-structure/#import-paths","title":"Import Paths","text":"<p>The project uses <code>@/</code> as an alias to <code>./src</code>:</p> <pre><code>// Instead of relative imports\nimport { Button } from '../../../components/ui/button';\n\n// Use the alias\nimport { Button } from '@/components/ui/button';\n</code></pre> <p>Configured in <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/project-structure/#next-steps","title":"Next Steps","text":"<ul> <li>Development - Learn the development workflow</li> <li>Architecture - Understand how modules connect</li> <li>Chat System - Deep dive into ChatProvider</li> </ul>"},{"location":"modules/","title":"Modules Overview","text":"<p>This section provides detailed documentation for each major module in the AI Chatbot application.</p>"},{"location":"modules/#module-architecture","title":"Module Architecture","text":"<pre><code>graph TB\n    subgraph Presentation[\"Presentation Layer\"]\n        Components[React Components]\n        Blocks[Content Blocks]\n    end\n\n    subgraph Core[\"Core Modules\"]\n        Chat[Chat System]\n        AI[AI Integration]\n        Persist[Persistence]\n    end\n\n    subgraph Data[\"Data Layer\"]\n        DB[(IndexedDB)]\n    end\n\n    subgraph External[\"External\"]\n        OpenAI[OpenAI API]\n        Tavily[Tavily API]\n    end\n\n    Components --&gt; Chat\n    Blocks --&gt; AI\n    Chat --&gt; Persist\n    Chat --&gt; AI\n    Persist --&gt; DB\n    AI --&gt; OpenAI\n    AI --&gt; Tavily</code></pre>"},{"location":"modules/#module-index","title":"Module Index","text":"Module Description Key Files Chat System State management, message handling, context provider <code>ChatProvider.tsx</code>, <code>useChat2()</code> AI Integration Models, tools, prompts, streaming <code>tools.ts</code>, <code>model.ts</code>, <code>/api/chat</code> Rendering Blocks Interactive content (forms, charts, code, cards) <code>ContentBlock.tsx</code>, <code>FormContent.tsx</code> Persistence IndexedDB storage, hooks, delayed creation <code>useChatPersistence.ts</code>, <code>schema.ts</code>"},{"location":"modules/#quick-reference","title":"Quick Reference","text":""},{"location":"modules/#where-to-look-for","title":"Where to Look For...","text":"Task Module Key Files Modify chat state Chat System <code>ChatProvider.tsx</code> Add a new AI tool AI Integration <code>tools.ts</code>, <code>content-blocks.ts</code> Change how tools render Rendering Blocks <code>ContentBlock.tsx</code>, <code>*Content.tsx</code> Modify database schema Persistence <code>schema.ts</code>, <code>types.ts</code> Add new message fields Persistence <code>useChatPersistence.ts</code> Change model selection AI Integration <code>models.ts</code>, <code>model.ts</code> Modify streaming behavior AI Integration <code>/api/chat/route.ts</code>"},{"location":"modules/#module-dependencies","title":"Module Dependencies","text":"<pre><code>graph LR\n    Chat[Chat System]\n    AI[AI Integration]\n    Blocks[Rendering Blocks]\n    Persist[Persistence]\n\n    Chat --&gt; AI\n    Chat --&gt; Persist\n    Blocks --&gt; AI</code></pre> <ul> <li>Chat System depends on AI Integration and Persistence</li> <li>Rendering Blocks depends on AI Integration (for type definitions)</li> <li>Persistence is independent (only depends on Dexie)</li> <li>AI Integration is independent (only depends on AI SDK)</li> </ul>"},{"location":"modules/ai-integration/","title":"AI Integration","text":"<p>The AI Integration module handles model creation, tool definitions, system prompts, and streaming responses.</p>"},{"location":"modules/ai-integration/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph Client[\"Client Side\"]\n        Provider[ChatProvider]\n        Transport[DefaultChatTransport]\n    end\n\n    subgraph API[\"API Route\"]\n        Route[\"/api/chat\"]\n        GetModel[getModel]\n        StreamText[streamText]\n    end\n\n    subgraph Tools[\"AI Tools\"]\n        Form[generateForm]\n        Chart[generateChart]\n        Code[generateCode]\n        Card[generateCard]\n        Search[webSearch]\n    end\n\n    subgraph External[\"External APIs\"]\n        OpenAI[OpenAI API]\n        Tavily[Tavily API]\n    end\n\n    Provider --&gt; Transport\n    Transport -.-&gt;|HTTP POST| Route\n    Route --&gt; GetModel\n    Route --&gt; StreamText\n    StreamText --&gt; Tools\n    GetModel --&gt; OpenAI\n    Search --&gt; Tavily</code></pre>"},{"location":"modules/ai-integration/#model-factory","title":"Model Factory","text":"<p>The <code>getModel()</code> function creates language model instances with consistent configuration.</p> <p>Location: <code>src/lib/ai/model.ts</code></p> <pre><code>import { openai } from '@ai-sdk/openai';\nimport { wrapLanguageModel } from 'ai';\nimport { MODELS } from './models';\nimport { config } from '@/config';\n\nexport function getModel(modelId: string) {\n  // Validate model ID\n  const modelConfig = MODELS.find(m =&gt; m.id === modelId);\n  if (!modelConfig) {\n    throw new Error(`Unknown model: ${modelId}`);\n  }\n\n  // Create base model\n  let model = openai(modelId, {\n    // Use chat-completions for compatibility\n    simulateStreaming: false,\n  });\n\n  // Wrap with DevTools middleware in development\n  if (config.ai.debug) {\n    model = wrapLanguageModel({\n      model,\n      middleware: devToolsMiddleware,\n    });\n  }\n\n  return model;\n}\n</code></pre>"},{"location":"modules/ai-integration/#model-catalog","title":"Model Catalog","text":"<p>Location: <code>src/lib/ai/models.ts</code></p> <pre><code>export const MODELS = [\n  { id: 'gpt-5', name: 'GPT-5', provider: 'openai' },\n  { id: 'gpt-5-mini', name: 'GPT-5 Mini', provider: 'openai' },\n  { id: 'gpt-4o', name: 'GPT-4o', provider: 'openai' },\n  { id: 'gpt-4o-mini', name: 'GPT-4o Mini', provider: 'openai' },\n] as const;\n\nexport const DEFAULT_MODEL = MODELS[0]; // GPT-5\n\nexport type ModelId = typeof MODELS[number]['id'];\n</code></pre>"},{"location":"modules/ai-integration/#ai-tools","title":"AI Tools","text":"<p>The application includes 5 AI tools for generating interactive content.</p> <p>Location: <code>src/lib/ai/tools.ts</code></p>"},{"location":"modules/ai-integration/#tool-architecture","title":"Tool Architecture","text":"<pre><code>graph LR\n    subgraph Definition[\"Tool Definition\"]\n        Schema[Zod Schema]\n        Execute[Execute Function]\n    end\n\n    subgraph Runtime[\"Runtime\"]\n        Validate[Validate Input]\n        Run[Run Execute]\n        Return[Return Output]\n    end\n\n    Schema --&gt; Validate\n    Validate --&gt; Run\n    Execute --&gt; Run\n    Run --&gt; Return</code></pre>"},{"location":"modules/ai-integration/#tool-definitions","title":"Tool Definitions","text":""},{"location":"modules/ai-integration/#generateform","title":"generateForm","text":"<p>Creates interactive forms for data collection.</p> <pre><code>export const generateForm = tool&lt;FormContentData, FormContentData&gt;({\n  description: \"Generate an interactive form for collecting user input\",\n  inputSchema: FormContentDataSchema,\n  execute: async (input) =&gt; input, // Pass-through\n});\n</code></pre> <p>Schema:</p> <pre><code>const FormContentDataSchema = z.object({\n  type: z.literal(\"form\"),\n  title: z.string(),\n  description: z.string().optional(),\n  fields: z.array(FormFieldSchema),\n  submitLabel: z.string().optional(),\n});\n\nconst FormFieldSchema = z.object({\n  name: z.string(),\n  label: z.string(),\n  type: z.enum([\n    \"text\", \"textarea\", \"email\", \"number\",\n    \"select\", \"checkbox\", \"radio\", \"date\",\n    \"slider\", \"file\"\n  ]),\n  placeholder: z.string().optional(),\n  required: z.boolean().optional(),\n  options: z.array(z.string()).optional(), // For select, radio\n  min: z.number().optional(), // For slider\n  max: z.number().optional(),\n  step: z.number().optional(),\n});\n</code></pre>"},{"location":"modules/ai-integration/#generatechart","title":"generateChart","text":"<p>Creates data visualizations using Recharts.</p> <pre><code>export const generateChart = tool&lt;ChartContentData, ChartContentData&gt;({\n  description: \"Generate a data visualization chart\",\n  inputSchema: ChartContentDataSchema,\n  execute: async (input) =&gt; input,\n});\n</code></pre> <p>Schema:</p> <pre><code>const ChartContentDataSchema = z.object({\n  type: z.literal(\"chart\"),\n  chartType: z.enum([\"line\", \"bar\", \"pie\", \"area\"]),\n  title: z.string(),\n  description: z.string().optional(),\n  data: z.array(z.object({\n    label: z.string(),\n    value: z.number(),\n  })),\n});\n</code></pre>"},{"location":"modules/ai-integration/#generatecode","title":"generateCode","text":"<p>Creates syntax-highlighted code blocks.</p> <pre><code>export const generateCode = tool&lt;CodeContentData, CodeContentData&gt;({\n  description: \"Generate a syntax-highlighted code block\",\n  inputSchema: CodeContentDataSchema,\n  execute: async (input) =&gt; input,\n});\n</code></pre> <p>Schema:</p> <pre><code>const CodeContentDataSchema = z.object({\n  type: z.literal(\"code\"),\n  language: z.string(),\n  filename: z.string().optional(),\n  code: z.string(),\n  editable: z.boolean().optional(),\n  showLineNumbers: z.boolean().optional(),\n});\n</code></pre>"},{"location":"modules/ai-integration/#generatecard","title":"generateCard","text":"<p>Creates rich content cards with optional media.</p> <pre><code>export const generateCard = tool&lt;CardContentData, CardContentData&gt;({\n  description: \"Generate a rich content card\",\n  inputSchema: CardContentDataSchema,\n  execute: async (input) =&gt; input,\n});\n</code></pre> <p>Schema:</p> <pre><code>const CardContentDataSchema = z.object({\n  type: z.literal(\"card\"),\n  title: z.string(),\n  description: z.string().optional(),\n  content: z.string().optional(),\n  media: z.object({\n    type: z.enum([\"image\", \"video\"]),\n    url: z.string(),\n    alt: z.string().optional(),\n  }).optional(),\n  actions: z.array(z.object({\n    label: z.string(),\n    action: z.string(),\n    variant: z.enum([\"default\", \"secondary\", \"destructive\", \"outline\"]).optional(),\n  })).optional(),\n});\n</code></pre>"},{"location":"modules/ai-integration/#websearch","title":"webSearch","text":"<p>Searches the web using Tavily API (optional).</p> <pre><code>// src/lib/ai/tavily.ts\nexport const webSearch = tool({\n  description: \"Search the web for current information\",\n  inputSchema: z.object({\n    query: z.string(),\n    topic: z.enum([\"general\", \"news\", \"finance\"]).optional(),\n    maxResults: z.number().min(1).max(10).optional(),\n  }),\n  execute: async ({ query, topic, maxResults }) =&gt; {\n    const client = getClient(); // Lazy initialization\n    const result = await client.search(query, {\n      topic: topic || \"general\",\n      maxResults: maxResults || 5,\n    });\n    return {\n      query,\n      answer: result.answer,\n      results: result.results.map(r =&gt; ({\n        title: r.title,\n        url: r.url,\n        content: r.content,\n        score: r.score,\n      })),\n    };\n  },\n});\n</code></pre>"},{"location":"modules/ai-integration/#tool-export","title":"Tool Export","text":"<pre><code>// src/lib/ai/tools.ts\nexport const chatTools = {\n  generateForm,\n  generateChart,\n  generateCode,\n  generateCard,\n  // Conditionally include web search\n  ...(config.ai.webSearch.enabled ? { webSearch } : {}),\n};\n</code></pre>"},{"location":"modules/ai-integration/#system-prompts","title":"System Prompts","text":"<p>Location: <code>src/lib/ai/prompts.ts</code></p> <p>The system prompt guides the AI in selecting appropriate tools:</p> <pre><code>export const SYSTEM_PROMPT = `You are a helpful assistant with access to tools for creating interactive content.\n\n## Tool Selection Guide\n\nYou have 4 tools available. Choose the correct tool based on the user's intent:\n\n### generateForm\nUSE WHEN: The user needs to COLLECT or INPUT data from someone.\n- Trigger words: form, survey, questionnaire, registration, sign up...\n- Creates: Interactive forms with text fields, dropdowns, checkboxes, etc.\n- DO NOT use for: Displaying existing information, showing code\n\n### generateChart\nUSE WHEN: The user wants to VISUALIZE numerical data or statistics.\n- Trigger words: chart, graph, plot, visualize, statistics, trends...\n- Creates: Line charts, bar charts, pie charts, or area charts\n- DO NOT use for: Collecting user input, showing code\n\n### generateCode\nUSE WHEN: The user asks for CODE or PROGRAMMING help.\n- Trigger words: code, function, script, program, snippet...\n- Creates: Syntax-highlighted code blocks\n- DO NOT use for: Displaying non-code text, forms\n\n### generateCard\nUSE WHEN: The user wants to DISPLAY or SHOWCASE structured information.\n- Trigger words: card, summary, profile, product info, display...\n- Creates: Rich content cards with optional images and action buttons\n- DO NOT use for: Collecting input (use generateForm)\n\n## Decision Examples\n\n| User Request | Correct Tool |\n|--------------|--------------|\n| \"Create a contact form\" | generateForm |\n| \"Show sales data as a chart\" | generateChart |\n| \"Write a Python function\" | generateCode |\n| \"Create a product card\" | generateCard |\n\n## Important Guidelines\n\n1. When you use a tool, do NOT repeat the tool's content in your text response.\n2. Only provide brief context before the tool call or follow-up comments after.\n3. If unsure which tool to use, consider the PRIMARY intent.\n4. You can use multiple tools in a single response if needed.\n5. If the request doesn't match any tool's purpose, respond with text.`;\n</code></pre>"},{"location":"modules/ai-integration/#api-route","title":"API Route","text":"<p>Location: <code>src/app/api/chat/route.ts</code></p> <pre><code>import { streamText, convertToModelMessages, stepCountIs } from 'ai';\nimport { getModel } from '@/lib/ai/model';\nimport { chatTools } from '@/lib/ai/tools';\nimport { SYSTEM_PROMPT } from '@/lib/ai/prompts';\n\nexport async function POST(request: Request) {\n  const { messages, model: selectedModel } = await request.json();\n\n  const result = streamText({\n    model: getModel(selectedModel),\n    system: SYSTEM_PROMPT,\n    messages: convertToModelMessages(messages),\n    tools: chatTools,\n    stopWhen: stepCountIs(3), // Limit tool call loops\n  });\n\n  return result.toUIMessageStreamResponse();\n}\n</code></pre>"},{"location":"modules/ai-integration/#request-format","title":"Request Format","text":"<pre><code>interface ChatRequest {\n  messages: UIMessage[];\n  model: string;\n}\n</code></pre>"},{"location":"modules/ai-integration/#response-format","title":"Response Format","text":"<p>The response is a streaming response using the AI SDK's format:</p> <ul> <li>Text chunks are streamed as they arrive</li> <li>Tool calls are included as special message parts</li> <li>Tool results are streamed after execution</li> </ul>"},{"location":"modules/ai-integration/#streaming-flow","title":"Streaming Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant OpenAI\n\n    Client-&gt;&gt;API: POST /api/chat\n    API-&gt;&gt;OpenAI: streamText()\n\n    loop Streaming Response\n        OpenAI--&gt;&gt;API: Token chunk\n        API--&gt;&gt;Client: Stream chunk\n        Client-&gt;&gt;Client: Update UI\n    end\n\n    alt Tool Call\n        OpenAI--&gt;&gt;API: tool_call\n        API-&gt;&gt;API: Execute tool\n        API--&gt;&gt;Client: tool result\n    end\n\n    OpenAI--&gt;&gt;API: Stream complete\n    API--&gt;&gt;Client: Close stream</code></pre>"},{"location":"modules/ai-integration/#adding-a-new-tool","title":"Adding a New Tool","text":"<p>See the Adding AI Tools Tutorial for a complete guide.</p> <p>Quick reference:</p> <ol> <li>Define schema in <code>src/types/content-blocks.ts</code></li> <li>Create tool in <code>src/lib/ai/tools.ts</code></li> <li>Create renderer in <code>src/components/blocks/</code></li> <li>Register in <code>ContentBlock.tsx</code></li> <li>Update system prompt</li> </ol>"},{"location":"modules/ai-integration/#related-modules","title":"Related Modules","text":"<ul> <li>Chat System - How the API is called</li> <li>Rendering Blocks - How tool results are displayed</li> <li>Tutorials - Step-by-step guide to adding tools</li> </ul>"},{"location":"modules/chat-system/","title":"Chat System","text":"<p>The Chat System module handles state management, message coordination, and serves as the central orchestration hub for the application.</p>"},{"location":"modules/chat-system/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph ChatProvider[\"ChatProvider Context\"]\n        Chat[AI SDK Chat]\n        Persist[useChatPersistence]\n        Title[useTitleGeneration]\n        State[Local State]\n    end\n\n    subgraph Consumers[\"Context Consumers\"]\n        Input[ChatInput]\n        Conv[ChatConversation]\n        Sidebar[Sidebar]\n    end\n\n    subgraph External[\"External\"]\n        API[\"/api/chat\"]\n        DB[(IndexedDB)]\n    end\n\n    Chat -.-&gt; API\n    Persist --&gt; DB\n    Title -.-&gt; API\n\n    Input --&gt; ChatProvider\n    Conv --&gt; ChatProvider\n    Sidebar --&gt; ChatProvider</code></pre>"},{"location":"modules/chat-system/#chatprovider","title":"ChatProvider","text":"<p>The <code>ChatProvider</code> component is the central context provider that orchestrates chat functionality.</p> <p>Location: <code>src/components/chat/ChatProvider.tsx</code></p>"},{"location":"modules/chat-system/#context-api","title":"Context API","text":"<pre><code>interface ChatContextType {\n  // Messages\n  messages: UIMessage[];\n  setMessages: Dispatch&lt;SetStateAction&lt;UIMessage[]&gt;&gt;;\n\n  // Actions\n  sendMessage: (text: string) =&gt; void;\n  clearMessages: () =&gt; void;\n  stop: () =&gt; void;\n\n  // Status\n  status: 'idle' | 'submitted' | 'streaming' | 'ready' | 'error';\n  isLoading: boolean;\n\n  // Model selection\n  selectedModel: string;\n  setSelectedModel: Dispatch&lt;SetStateAction&lt;string&gt;&gt;;\n\n  // Conversation management\n  conversationId: string;\n  switchConversation: (id: string) =&gt; Promise&lt;void&gt;;\n  startNewConversation: () =&gt; Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"modules/chat-system/#usage","title":"Usage","text":"<p>Access the context via the <code>useChat2()</code> hook:</p> <pre><code>import { useChat2 } from '@/components/chat/ChatProvider';\n\nfunction MyComponent() {\n  const {\n    messages,\n    sendMessage,\n    status,\n    isLoading,\n    conversationId,\n  } = useChat2();\n\n  const handleSend = () =&gt; {\n    sendMessage('Hello, AI!');\n  };\n\n  return (\n    &lt;div&gt;\n      {messages.map(msg =&gt; (\n        &lt;div key={msg.id}&gt;{msg.role}: {/* content */}&lt;/div&gt;\n      ))}\n      &lt;button onClick={handleSend} disabled={isLoading}&gt;\n        Send\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"modules/chat-system/#internal-structure","title":"Internal Structure","text":"<pre><code>export function ChatProvider({ children }: { children: React.ReactNode }) {\n  // Model selection state\n  const [selectedModel, setSelectedModel] = useState(DEFAULT_MODEL.id);\n\n  // Persistence hook\n  const {\n    conversationId,\n    storedMessages,\n    saveMessage,\n    updateMessage,\n    createConversation,\n    switchConversation: switchConversationDb,\n    isPersisted,\n  } = useChatPersistence();\n\n  // Title generation hook\n  const { generateTitle, generateFallbackTitle } = useTitleGeneration({\n    onTitleGenerated: (id, title) =&gt; updateTitle(id, title),\n  });\n\n  // AI SDK Chat instance\n  const chat = useMemo(() =&gt; new Chat({\n    transport: new DefaultChatTransport({\n      api: getApiUrl('chat'),\n      body: { model: selectedModel },\n    }),\n  }), [selectedModel]);\n\n  // AI SDK useChat hook\n  const {\n    messages,\n    setMessages,\n    sendMessage: sendChatMessage,\n    status,\n    stop,\n  } = useChat({ chat });\n\n  // Refs for race condition prevention\n  const previousMessagesRef = useRef&lt;UIMessage[]&gt;([]);\n  const hasLoadedRef = useRef(false);\n  const titleGeneratedRef = useRef(new Set&lt;string&gt;());\n\n  // ... effects and handlers\n}\n</code></pre>"},{"location":"modules/chat-system/#state-management","title":"State Management","text":""},{"location":"modules/chat-system/#message-state-flow","title":"Message State Flow","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; idle: Initial\n    idle --&gt; submitted: sendMessage()\n    submitted --&gt; streaming: Response starts\n    streaming --&gt; ready: Response complete\n    ready --&gt; idle: Next interaction\n    streaming --&gt; error: Error occurs\n    error --&gt; idle: Retry/new message</code></pre>"},{"location":"modules/chat-system/#status-states","title":"Status States","text":"Status Description UI Behavior <code>idle</code> Waiting for input Input enabled <code>submitted</code> Message sent, waiting Input disabled <code>streaming</code> Response arriving Show typing indicator <code>ready</code> Response complete Trigger persistence <code>error</code> Error occurred Show error message"},{"location":"modules/chat-system/#race-condition-prevention","title":"Race Condition Prevention","text":"<p>The provider uses refs to prevent race conditions:</p> <pre><code>// Prevent live query from overwriting during switch\nconst hasLoadedRef = useRef(false);\n\n// Track saved messages to avoid duplicates\nconst previousMessagesRef = useRef&lt;UIMessage[]&gt;([]);\n\n// Track which conversations have titles\nconst titleGeneratedRef = useRef(new Set&lt;string&gt;());\n</code></pre>"},{"location":"modules/chat-system/#message-persistence","title":"Message Persistence","text":"<p>Messages are persisted after streaming completes:</p> <pre><code>useEffect(() =&gt; {\n  if (status !== 'ready') return;\n\n  const previousIds = new Set(previousMessagesRef.current.map(m =&gt; m.id));\n  const newMessages = messages.filter(m =&gt; !previousIds.has(m.id));\n\n  if (newMessages.length === 0) return;\n\n  // Generate fallback title from first user message\n  const firstUserMsg = messages.find(m =&gt; m.role === 'user');\n  const fallbackTitle = firstUserMsg\n    ? generateFallbackTitle(getTextFromMessage(firstUserMsg))\n    : 'New Chat';\n\n  // Save each new message\n  (async () =&gt; {\n    for (const message of newMessages) {\n      await saveMessage(message, fallbackTitle);\n    }\n    previousMessagesRef.current = messages;\n  })();\n}, [messages, status]);\n</code></pre>"},{"location":"modules/chat-system/#title-generation","title":"Title Generation","text":"<p>Titles are generated after the first user+assistant exchange:</p> <pre><code>useEffect(() =&gt; {\n  if (status !== 'ready') return;\n\n  const userMsg = messages.find(m =&gt; m.role === 'user');\n  const assistantMsg = messages.find(m =&gt; m.role === 'assistant');\n\n  if (!userMsg || !assistantMsg) return;\n  if (titleGeneratedRef.current.has(conversationId)) return;\n\n  titleGeneratedRef.current.add(conversationId);\n  generateTitle(conversationId, getTextFromMessage(userMsg));\n}, [messages, status, conversationId]);\n</code></pre>"},{"location":"modules/chat-system/#conversation-switching","title":"Conversation Switching","text":"<pre><code>const switchConversation = useCallback(async (id: string) =&gt; {\n  // Clear current messages immediately\n  setMessages([]);\n\n  // Prevent live query from interfering\n  hasLoadedRef.current = true;\n\n  // Don't regenerate existing titles\n  titleGeneratedRef.current.add(id);\n\n  // Fetch messages directly (bypass live query lag)\n  const loadedMessages = await switchConversationDb(id);\n\n  if (loadedMessages.length &gt; 0) {\n    setMessages(loadedMessages);\n    previousMessagesRef.current = loadedMessages;\n  }\n}, [switchConversationDb, setMessages]);\n</code></pre>"},{"location":"modules/chat-system/#key-patterns","title":"Key Patterns","text":""},{"location":"modules/chat-system/#1-hook-composition","title":"1. Hook Composition","text":"<p>ChatProvider composes multiple hooks:</p> <pre><code>// Persistence layer\nconst { saveMessage, ... } = useChatPersistence();\n\n// Title generation layer\nconst { generateTitle, ... } = useTitleGeneration();\n\n// AI SDK layer\nconst { messages, sendMessage, ... } = useChat({ chat });\n</code></pre>"},{"location":"modules/chat-system/#2-deferred-execution","title":"2. Deferred Execution","text":"<p>Heavy operations are deferred to avoid blocking:</p> <pre><code>// Title generation is async and non-blocking\ngenerateTitle(conversationId, userText); // No await\n\n// Persistence happens after streaming completes\nif (status === 'ready') {\n  // Save messages\n}\n</code></pre>"},{"location":"modules/chat-system/#3-ref-based-tracking","title":"3. Ref-based Tracking","text":"<p>Refs track state that shouldn't trigger re-renders:</p> <pre><code>// Track saved messages without re-renders\nconst previousMessagesRef = useRef&lt;UIMessage[]&gt;([]);\n\n// Check: have we saved this message?\nconst isSaved = previousMessagesRef.current.some(m =&gt; m.id === message.id);\n</code></pre>"},{"location":"modules/chat-system/#common-operations","title":"Common Operations","text":""},{"location":"modules/chat-system/#send-a-message","title":"Send a Message","text":"<pre><code>const { sendMessage, isLoading } = useChat2();\n\n// In a handler\nconst handleSubmit = () =&gt; {\n  if (!isLoading &amp;&amp; text.trim()) {\n    sendMessage(text);\n    setText('');\n  }\n};\n</code></pre>"},{"location":"modules/chat-system/#start-new-conversation","title":"Start New Conversation","text":"<pre><code>const { startNewConversation } = useChat2();\n\nconst handleNewChat = async () =&gt; {\n  await startNewConversation();\n};\n</code></pre>"},{"location":"modules/chat-system/#switch-conversation","title":"Switch Conversation","text":"<pre><code>const { switchConversation } = useChat2();\n\nconst handleSelect = async (conversationId: string) =&gt; {\n  await switchConversation(conversationId);\n};\n</code></pre>"},{"location":"modules/chat-system/#stop-generation","title":"Stop Generation","text":"<pre><code>const { stop, status } = useChat2();\n\n{status === 'streaming' &amp;&amp; (\n  &lt;button onClick={stop}&gt;Stop generating&lt;/button&gt;\n)}\n</code></pre>"},{"location":"modules/chat-system/#related-modules","title":"Related Modules","text":"<ul> <li>AI Integration - How messages are processed</li> <li>Persistence - How messages are stored</li> <li>Rendering Blocks - How messages are displayed</li> </ul>"},{"location":"modules/persistence/","title":"Persistence","text":"<p>The Persistence module handles local data storage using IndexedDB via Dexie, providing conversation and message persistence.</p>"},{"location":"modules/persistence/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph Hooks[\"React Hooks\"]\n        Persist[useChatPersistence]\n        Conv[useConversations]\n        Title[useTitleGeneration]\n    end\n\n    subgraph Dexie[\"Dexie Layer\"]\n        Schema[Database Schema]\n        LiveQuery[Live Queries]\n        Transaction[Transactions]\n    end\n\n    subgraph Storage[\"Browser Storage\"]\n        IDB[(IndexedDB)]\n    end\n\n    Persist --&gt; Schema\n    Persist --&gt; LiveQuery\n    Persist --&gt; Transaction\n    Conv --&gt; Schema\n    Conv --&gt; LiveQuery\n    Title --&gt; Schema\n\n    Schema --&gt; IDB\n    LiveQuery --&gt; IDB\n    Transaction --&gt; IDB</code></pre>"},{"location":"modules/persistence/#database-schema","title":"Database Schema","text":"<p>Location: <code>src/lib/db/schema.ts</code></p> <pre><code>import Dexie, { type Table } from 'dexie';\nimport type { ConversationRecord, MessageRecord } from './types';\n\nexport class ChatDatabase extends Dexie {\n  conversations!: Table&lt;ConversationRecord, string&gt;;\n  messages!: Table&lt;MessageRecord, number&gt;;\n\n  constructor() {\n    super('AIChatbotDB');\n\n    this.version(1).stores({\n      conversations: 'id, updatedAt, userId',\n      messages: '++id, conversationId, userId, createdAt',\n    });\n  }\n}\n\nexport const db = new ChatDatabase();\n</code></pre>"},{"location":"modules/persistence/#schema-diagram","title":"Schema Diagram","text":"<pre><code>erDiagram\n    conversations {\n        string id PK \"nanoid\"\n        string title\n        datetime createdAt\n        datetime updatedAt\n        string userId \"optional\"\n    }\n\n    messages {\n        number id PK \"auto-increment\"\n        string visibleId \"UIMessage.id\"\n        string conversationId FK\n        string role \"user|assistant|system\"\n        string content \"JSON stringified\"\n        string userId \"optional\"\n        datetime createdAt\n    }\n\n    conversations ||--o{ messages : \"has many\"</code></pre>"},{"location":"modules/persistence/#index-strategy","title":"Index Strategy","text":"Table Index Purpose <code>conversations</code> <code>id</code> Primary key lookup <code>conversations</code> <code>updatedAt</code> Sort by most recent <code>conversations</code> <code>userId</code> Multi-user filtering <code>messages</code> <code>id</code> Primary key (auto-increment) <code>messages</code> <code>conversationId</code> Fetch messages for a conversation <code>messages</code> <code>userId</code> Multi-user filtering <code>messages</code> <code>createdAt</code> Chronological sorting"},{"location":"modules/persistence/#type-definitions","title":"Type Definitions","text":"<p>Location: <code>src/lib/db/types.ts</code></p> <pre><code>export interface ConversationRecord {\n  id: string;           // nanoid generated\n  title: string;        // LLM or fallback generated\n  createdAt: Date;\n  updatedAt: Date;      // Updated on each new message\n  userId?: string;      // Placeholder for auth\n}\n\nexport interface MessageRecord {\n  id?: number;          // Auto-incremented by Dexie\n  visibleId: string;    // Maps to UIMessage.id (from AI SDK)\n  conversationId: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;      // JSON stringified UIMessage.parts\n  userId?: string;\n  createdAt: Date;\n}\n</code></pre>"},{"location":"modules/persistence/#usechatpersistence-hook","title":"useChatPersistence Hook","text":"<p>Location: <code>src/hooks/useChatPersistence.ts</code></p> <p>The main persistence hook handling message save/load operations.</p>"},{"location":"modules/persistence/#api","title":"API","text":"<pre><code>interface UseChatPersistenceOptions {\n  conversationId?: string;\n  userId?: string;\n}\n\ninterface UseChatPersistenceReturn {\n  conversationId: string;\n  storedMessages: UIMessage[];\n  isLoading: boolean;\n  isPersisted: boolean;\n  saveMessage: (message: UIMessage, fallbackTitle?: string) =&gt; Promise&lt;void&gt;;\n  updateMessage: (message: UIMessage) =&gt; Promise&lt;void&gt;;\n  createConversation: () =&gt; Promise&lt;string&gt;;\n  clearConversation: () =&gt; Promise&lt;void&gt;;\n  deleteConversation: (id?: string) =&gt; Promise&lt;void&gt;;\n  switchConversation: (id: string) =&gt; Promise&lt;UIMessage[]&gt;;\n}\n</code></pre>"},{"location":"modules/persistence/#usage","title":"Usage","text":"<pre><code>import { useChatPersistence } from '@/hooks/useChatPersistence';\n\nfunction MyComponent() {\n  const {\n    conversationId,\n    storedMessages,\n    saveMessage,\n    switchConversation,\n    isPersisted,\n  } = useChatPersistence();\n\n  // Save a new message\n  const handleSave = async (message: UIMessage) =&gt; {\n    await saveMessage(message, 'Fallback Title');\n  };\n\n  // Switch to another conversation\n  const handleSwitch = async (id: string) =&gt; {\n    const messages = await switchConversation(id);\n    // messages are returned for immediate use\n  };\n}\n</code></pre>"},{"location":"modules/persistence/#delayed-conversation-creation","title":"Delayed Conversation Creation","text":"<p>A key pattern preventing orphan records:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; InMemory: createConversation()\n\n    state InMemory {\n        [*] --&gt; ID_Generated\n        ID_Generated --&gt; Waiting: isPersisted = false\n    }\n\n    Waiting --&gt; Persisted: saveMessage()\n\n    state Persisted {\n        [*] --&gt; Transaction\n        Transaction --&gt; Create_Conv: !exists\n        Create_Conv --&gt; Add_Message\n        Add_Message --&gt; [*]\n    }\n\n    Persisted --&gt; [*]: isPersisted = true</code></pre> <p>Implementation:</p> <pre><code>const saveMessage = useCallback(async (message: UIMessage, fallbackTitle?: string) =&gt; {\n  await db.transaction('rw', db.messages, db.conversations, async () =&gt; {\n    // Only create conversation on first message save\n    if (!isPersistedRef.current) {\n      const existingConv = await db.conversations.get(currentConversationId);\n      if (!existingConv) {\n        await db.conversations.put({\n          id: currentConversationId,\n          title: fallbackTitle || 'New Chat',\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          userId,\n        });\n      }\n      isPersistedRef.current = true;\n    }\n\n    // Check for duplicate message\n    const existing = await db.messages\n      .where('conversationId')\n      .equals(currentConversationId)\n      .filter(msg =&gt; msg.visibleId === message.id)\n      .first();\n\n    if (existing) return;\n\n    // Insert message\n    await db.messages.add({\n      visibleId: message.id,\n      conversationId: currentConversationId,\n      role: message.role,\n      content: JSON.stringify(message.parts),\n      userId,\n      createdAt: new Date(),\n    });\n\n    // Update conversation timestamp\n    await db.conversations.update(currentConversationId, {\n      updatedAt: new Date(),\n    });\n  });\n}, [currentConversationId, userId]);\n</code></pre> <p>Benefits:</p> <ul> <li>No orphan conversations (empty records)</li> <li>Simpler UI logic (all conversations have messages)</li> <li>Atomic operation ensures data integrity</li> </ul>"},{"location":"modules/persistence/#useconversations-hook","title":"useConversations Hook","text":"<p>Location: <code>src/hooks/useConversations.ts</code></p> <p>Manages the conversation list for the sidebar.</p>"},{"location":"modules/persistence/#api_1","title":"API","text":"<pre><code>interface UseConversationsOptions {\n  userId?: string;\n  limit?: number;  // Default: 50\n}\n\ninterface UseConversationsReturn {\n  conversations: ConversationRecord[];\n  isLoading: boolean;\n  updateTitle: (id: string, title: string) =&gt; Promise&lt;void&gt;;\n  deleteConversation: (id: string) =&gt; Promise&lt;void&gt;;\n  clearAllConversations: () =&gt; Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"modules/persistence/#usage_1","title":"Usage","text":"<pre><code>import { useConversations } from '@/hooks/useConversations';\n\nfunction Sidebar() {\n  const {\n    conversations,\n    isLoading,\n    deleteConversation,\n    updateTitle,\n  } = useConversations({ limit: 50 });\n\n  return (\n    &lt;ul&gt;\n      {conversations.map(conv =&gt; (\n        &lt;li key={conv.id}&gt;\n          {conv.title}\n          &lt;button onClick={() =&gt; deleteConversation(conv.id)}&gt;\n            Delete\n          &lt;/button&gt;\n        &lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre>"},{"location":"modules/persistence/#cascade-delete","title":"Cascade Delete","text":"<pre><code>const deleteConversation = useCallback(async (id: string) =&gt; {\n  // Delete messages first (children)\n  await db.messages.where('conversationId').equals(id).delete();\n  // Then delete conversation (parent)\n  await db.conversations.delete(id);\n}, []);\n</code></pre>"},{"location":"modules/persistence/#usetitlegeneration-hook","title":"useTitleGeneration Hook","text":"<p>Location: <code>src/hooks/useTitleGeneration.ts</code></p> <p>Generates conversation titles via LLM with retry logic.</p>"},{"location":"modules/persistence/#api_2","title":"API","text":"<pre><code>interface UseTitleGenerationOptions {\n  onTitleGenerated?: (conversationId: string, title: string) =&gt; void;\n  onError?: (error: Error) =&gt; void;\n}\n\ninterface UseTitleGenerationReturn {\n  generateTitle: (conversationId: string, userMessage: string) =&gt; Promise&lt;void&gt;;\n  generateFallbackTitle: (userMessage: string) =&gt; string;\n}\n</code></pre>"},{"location":"modules/persistence/#retry-logic","title":"Retry Logic","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Attempt1\n\n    Attempt1 --&gt; Success: API Success\n    Attempt1 --&gt; Wait1: API Failure\n\n    Wait1 --&gt; Attempt2: After 1s\n\n    Attempt2 --&gt; Success: API Success\n    Attempt2 --&gt; Wait2: API Failure\n\n    Wait2 --&gt; Attempt3: After 2s\n\n    Attempt3 --&gt; Success: API Success\n    Attempt3 --&gt; Fallback: API Failure\n\n    Success --&gt; [*]: Update DB\n    Fallback --&gt; [*]: Use truncated text</code></pre> <p>Implementation:</p> <pre><code>const generateTitle = async (conversationId: string, userMessage: string) =&gt; {\n  const fallbackTitle = generateFallbackTitle(userMessage);\n  let attempts = 0;\n  const maxAttempts = 3;\n  const baseDelay = 1000; // 1 second\n\n  const attemptGeneration = async (): Promise&lt;string&gt; =&gt; {\n    try {\n      const response = await fetch(getApiUrl('generate-title'), {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ userMessage, conversationId }),\n      });\n\n      if (!response.ok) throw new Error('Title generation failed');\n\n      const data = await response.json();\n      return data.title || fallbackTitle;\n    } catch (error) {\n      attempts++;\n      if (attempts &lt; maxAttempts) {\n        // Exponential backoff: 1s, 2s, 4s\n        const delay = baseDelay * Math.pow(2, attempts - 1);\n        await new Promise(resolve =&gt; setTimeout(resolve, delay));\n        return attemptGeneration();\n      }\n      return fallbackTitle;\n    }\n  };\n\n  const title = await attemptGeneration();\n  onTitleGenerated?.(conversationId, title);\n};\n\nconst generateFallbackTitle = (userMessage: string): string =&gt; {\n  const maxLength = 50;\n  if (userMessage.length &lt;= maxLength) return userMessage;\n\n  // Truncate at word boundary\n  const truncated = userMessage.slice(0, maxLength);\n  const lastSpace = truncated.lastIndexOf(' ');\n  return lastSpace &gt; 0\n    ? truncated.slice(0, lastSpace) + '...'\n    : truncated + '...';\n};\n</code></pre>"},{"location":"modules/persistence/#live-query-pattern","title":"Live Query Pattern","text":"<p>Dexie's <code>useLiveQuery</code> provides reactive data subscriptions:</p> <pre><code>import { useLiveQuery } from 'dexie-react-hooks';\n\n// Automatically re-renders when data changes\nconst conversations = useLiveQuery(\n  () =&gt; db.conversations\n    .orderBy('updatedAt')\n    .reverse()\n    .limit(50)\n    .toArray(),\n  [] // Dependencies\n);\n</code></pre>"},{"location":"modules/persistence/#how-it-works","title":"How It Works","text":"<ol> <li>Initial query runs and returns data</li> <li>Hook subscribes to IndexedDB change events</li> <li>When data changes (add, update, delete), query re-runs</li> <li>Component re-renders with new data</li> </ol>"},{"location":"modules/persistence/#bypassing-live-queries","title":"Bypassing Live Queries","text":"<p>For user-triggered actions needing immediate feedback:</p> <pre><code>// Direct query (no subscription)\nconst switchConversation = async (id: string) =&gt; {\n  const messages = await db.messages\n    .where('conversationId')\n    .equals(id)\n    .sortBy('createdAt');\n\n  return messages; // Use immediately\n};\n</code></pre> <p>When to use direct queries:</p> <ul> <li>Conversation switching (avoid reactivity lag)</li> <li>One-time data fetches</li> <li>Immediate user feedback needed</li> </ul>"},{"location":"modules/persistence/#transaction-handling","title":"Transaction Handling","text":"<p>Dexie transactions provide ACID guarantees:</p> <pre><code>await db.transaction('rw', db.messages, db.conversations, async () =&gt; {\n  // All operations succeed or all fail\n\n  // 1. Create conversation\n  await db.conversations.put({ ... });\n\n  // 2. Add message\n  await db.messages.add({ ... });\n\n  // 3. Update timestamp\n  await db.conversations.update(id, { updatedAt: new Date() });\n\n  // If any operation fails, all are rolled back\n});\n</code></pre> <p>Transaction modes:</p> Mode Description <code>r</code> Read-only <code>rw</code> Read-write <code>rw!</code> Read-write with upgrade"},{"location":"modules/persistence/#crud-operations-summary","title":"CRUD Operations Summary","text":""},{"location":"modules/persistence/#create","title":"Create","text":"<pre><code>// Create conversation (usually via saveMessage)\nawait db.conversations.put({\n  id: nanoid(),\n  title: 'New Chat',\n  createdAt: new Date(),\n  updatedAt: new Date(),\n});\n\n// Create message\nawait db.messages.add({\n  visibleId: message.id,\n  conversationId,\n  role: message.role,\n  content: JSON.stringify(message.parts),\n  createdAt: new Date(),\n});\n</code></pre>"},{"location":"modules/persistence/#read","title":"Read","text":"<pre><code>// Get single conversation\nconst conv = await db.conversations.get(id);\n\n// Get all messages for conversation\nconst messages = await db.messages\n  .where('conversationId')\n  .equals(id)\n  .sortBy('createdAt');\n\n// Get conversations sorted by date\nconst convs = await db.conversations\n  .orderBy('updatedAt')\n  .reverse()\n  .limit(50)\n  .toArray();\n</code></pre>"},{"location":"modules/persistence/#update","title":"Update","text":"<pre><code>// Update conversation title\nawait db.conversations.update(id, { title: 'New Title' });\n\n// Update message content\nawait db.messages.update(messageId, {\n  content: JSON.stringify(newParts),\n});\n</code></pre>"},{"location":"modules/persistence/#delete","title":"Delete","text":"<pre><code>// Delete single conversation (with cascade)\nawait db.messages.where('conversationId').equals(id).delete();\nawait db.conversations.delete(id);\n\n// Delete all conversations\nawait db.messages.clear();\nawait db.conversations.clear();\n</code></pre>"},{"location":"modules/persistence/#schema-migrations","title":"Schema Migrations","text":"<p>When adding new fields or tables, increment the version:</p> <pre><code>export class ChatDatabase extends Dexie {\n  constructor() {\n    super('AIChatbotDB');\n\n    // Version 1 - Initial schema\n    this.version(1).stores({\n      conversations: 'id, updatedAt, userId',\n      messages: '++id, conversationId, userId, createdAt',\n    });\n\n    // Version 2 - Add tags\n    this.version(2).stores({\n      conversations: 'id, updatedAt, userId, *tags', // Multi-entry index\n      messages: '++id, conversationId, userId, createdAt',\n    }).upgrade(tx =&gt; {\n      // Migration: initialize tags for existing conversations\n      return tx.table('conversations').toCollection().modify(conv =&gt; {\n        conv.tags = [];\n      });\n    });\n  }\n}\n</code></pre> <p>See the Extending Persistence Tutorial for a complete guide.</p>"},{"location":"modules/persistence/#browser-storage-limits","title":"Browser Storage Limits","text":"Browser Limit Chrome ~60% of available disk space Firefox ~50% of available disk space Safari ~1GB per origin Edge Same as Chrome <p>Storage Persistence</p> <p>IndexedDB data can be cleared by the browser or user. Consider implementing cloud sync for critical data.</p>"},{"location":"modules/persistence/#related-modules","title":"Related Modules","text":"<ul> <li>Chat System - How persistence integrates with chat</li> <li>Tutorials - Adding new fields</li> </ul>"},{"location":"modules/rendering-blocks/","title":"Rendering Blocks","text":"<p>The Rendering Blocks module handles the display of interactive content generated by AI tools.</p>"},{"location":"modules/rendering-blocks/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph Message[\"ChatMessageItem\"]\n        Detect[Detect tool- prefix]\n        Check[Check CONTENT_BLOCK_TOOLS]\n    end\n\n    subgraph Dispatcher[\"ContentBlock\"]\n        Switch[Switch on type]\n    end\n\n    subgraph Blocks[\"Block Components\"]\n        Form[FormContent]\n        Chart[ChartContent]\n        Code[CodeContent]\n        Card[CardContent]\n    end\n\n    Detect --&gt; Check\n    Check --&gt;|Is content block| Dispatcher\n    Switch --&gt; Form\n    Switch --&gt; Chart\n    Switch --&gt; Code\n    Switch --&gt; Card</code></pre>"},{"location":"modules/rendering-blocks/#content-block-types","title":"Content Block Types","text":"<p>Location: <code>src/types/content-blocks.ts</code></p> <p>The content block types use a discriminated union pattern for type safety:</p> <pre><code>// Discriminated union type\nexport type ContentBlock =\n  | FormContentData\n  | ChartContentData\n  | CodeContentData\n  | CardContentData;\n\n// Zod schema for runtime validation\nexport const ContentBlockSchema = z.discriminatedUnion(\"type\", [\n  FormContentDataSchema,\n  ChartContentDataSchema,\n  CodeContentDataSchema,\n  CardContentDataSchema,\n]);\n</code></pre> <p>This pattern ensures:</p> <ul> <li>TypeScript narrows the type based on the <code>type</code> field</li> <li>Exhaustive switch statements catch missing cases</li> <li>Runtime validation with Zod schemas</li> </ul>"},{"location":"modules/rendering-blocks/#tool-detection","title":"Tool Detection","text":"<p>Location: <code>src/components/chat/ChatMessageItem.tsx</code></p> <p>The message renderer detects tool outputs and routes them to the appropriate block:</p> <pre><code>const CONTENT_BLOCK_TOOLS = [\n  'generateForm',\n  'generateChart',\n  'generateCode',\n  'generateCard',\n];\n\n// In the render function\n{message.parts?.map((part, index) =&gt; {\n  // Check for tool parts\n  if (part.type.startsWith('tool-')) {\n    const toolName = part.type.replace('tool-', '');\n\n    // Route content block tools to ContentBlock\n    if (CONTENT_BLOCK_TOOLS.includes(toolName)) {\n      if (part.state === 'output-available' &amp;&amp; part.output) {\n        return (\n          &lt;ContentBlock\n            key={index}\n            content={part.output as ContentBlock}\n            messageId={message.id}\n          /&gt;\n        );\n      }\n      // Show loading state while tool executes\n      return &lt;ToolLoading key={index} toolName={toolName} /&gt;;\n    }\n\n    // Other tools use generic display\n    return &lt;Tool key={index} part={part} /&gt;;\n  }\n\n  // Text parts use Streamdown\n  if (part.type === 'text') {\n    return &lt;Streamdown key={index} text={part.text} /&gt;;\n  }\n})}\n</code></pre>"},{"location":"modules/rendering-blocks/#contentblock-dispatcher","title":"ContentBlock Dispatcher","text":"<p>Location: <code>src/components/blocks/ContentBlock.tsx</code></p> <p>The dispatcher routes content to the appropriate renderer:</p> <pre><code>\"use client\";\n\nimport { motion } from \"motion/react\";\nimport type { ContentBlock as ContentBlockType } from \"@/types/content-blocks\";\nimport { FormContent } from \"./FormContent\";\nimport { ChartContent } from \"./ChartContent\";\nimport { CodeContent } from \"./CodeContent\";\nimport { CardContent } from \"./CardContent\";\nimport { fadeInUp } from \"@/lib/motion/variants\";\n\ninterface ContentBlockProps {\n  content: ContentBlockType;\n  messageId: string;\n}\n\nexport function ContentBlock({ content, messageId }: ContentBlockProps) {\n  const renderContent = () =&gt; {\n    switch (content.type) {\n      case \"form\":\n        return &lt;FormContent data={content} messageId={messageId} /&gt;;\n      case \"chart\":\n        return &lt;ChartContent data={content} /&gt;;\n      case \"code\":\n        return &lt;CodeContent data={content} /&gt;;\n      case \"card\":\n        return &lt;CardContent data={content} /&gt;;\n      default:\n        // TypeScript ensures this is never reached\n        return null;\n    }\n  };\n\n  return (\n    &lt;motion.div\n      initial=\"hidden\"\n      animate=\"visible\"\n      variants={fadeInUp}\n      className=\"my-3 w-full\"\n    &gt;\n      {renderContent()}\n    &lt;/motion.div&gt;\n  );\n}\n</code></pre>"},{"location":"modules/rendering-blocks/#block-components","title":"Block Components","text":""},{"location":"modules/rendering-blocks/#formcontent","title":"FormContent","text":"<p>Location: <code>src/components/blocks/FormContent.tsx</code></p> <p>Renders interactive forms with validation and submission handling.</p> <pre><code>interface FormContentProps {\n  data: FormContentData;\n  messageId: string;\n}\n\nexport function FormContent({ data, messageId }: FormContentProps) {\n  const [values, setValues] = useState&lt;FormValues&gt;(() =&gt;\n    initializeFormValues(data.fields)\n  );\n  const [submitted, setSubmitted] = useState(false);\n\n  const handleSubmit = (e: React.FormEvent) =&gt; {\n    e.preventDefault();\n\n    // Validate required fields\n    const missingFields = data.fields\n      .filter(f =&gt; f.required &amp;&amp; !values[f.name])\n      .map(f =&gt; f.label);\n\n    if (missingFields.length &gt; 0) {\n      toast.error(`Please fill in: ${missingFields.join(', ')}`);\n      return;\n    }\n\n    console.log('Form submitted:', { messageId, values });\n    toast.success('Form submitted successfully!');\n    setSubmitted(true);\n  };\n\n  return (\n    &lt;Card&gt;\n      &lt;CardHeader&gt;\n        &lt;CardTitle&gt;{data.title}&lt;/CardTitle&gt;\n        {data.description &amp;&amp; (\n          &lt;CardDescription&gt;{data.description}&lt;/CardDescription&gt;\n        )}\n      &lt;/CardHeader&gt;\n      &lt;CardContent&gt;\n        &lt;form onSubmit={handleSubmit}&gt;\n          &lt;motion.div variants={formFieldContainer}&gt;\n            {data.fields.map(field =&gt; (\n              &lt;motion.div key={field.name} variants={formField}&gt;\n                {renderField(field, values, setValues, submitted)}\n              &lt;/motion.div&gt;\n            ))}\n          &lt;/motion.div&gt;\n          &lt;Button type=\"submit\" disabled={submitted}&gt;\n            {data.submitLabel || 'Submit'}\n          &lt;/Button&gt;\n        &lt;/form&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre> <p>Supported Field Types:</p> Type Component Props <code>text</code> Input placeholder, required <code>textarea</code> Textarea placeholder, required <code>email</code> Input (type=\"email\") placeholder, required <code>number</code> Input (type=\"number\") placeholder, required <code>select</code> Select options, placeholder <code>checkbox</code> Checkbox label <code>radio</code> RadioGroup options <code>date</code> Input (type=\"date\") required <code>slider</code> Slider min, max, step <code>file</code> Input (type=\"file\") -"},{"location":"modules/rendering-blocks/#chartcontent","title":"ChartContent","text":"<p>Location: <code>src/components/blocks/ChartContent.tsx</code></p> <p>Renders data visualizations using Recharts.</p> <pre><code>interface ChartContentProps {\n  data: ChartContentData;\n}\n\nexport function ChartContent({ data }: ChartContentProps) {\n  // Transform data for Recharts\n  const chartData = data.data.map(point =&gt; ({\n    name: point.label,\n    value: point.value,\n  }));\n\n  const renderChart = () =&gt; {\n    switch (data.chartType) {\n      case 'line':\n        return (\n          &lt;LineChart data={chartData}&gt;\n            &lt;CartesianGrid strokeDasharray=\"3 3\" /&gt;\n            &lt;XAxis dataKey=\"name\" /&gt;\n            &lt;YAxis /&gt;\n            &lt;Tooltip /&gt;\n            &lt;Legend /&gt;\n            &lt;Line type=\"monotone\" dataKey=\"value\" stroke=\"var(--color-chart-1)\" /&gt;\n          &lt;/LineChart&gt;\n        );\n      case 'bar':\n        return (\n          &lt;BarChart data={chartData}&gt;\n            &lt;CartesianGrid strokeDasharray=\"3 3\" /&gt;\n            &lt;XAxis dataKey=\"name\" /&gt;\n            &lt;YAxis /&gt;\n            &lt;Tooltip /&gt;\n            &lt;Legend /&gt;\n            &lt;Bar dataKey=\"value\" fill=\"var(--color-chart-1)\" /&gt;\n          &lt;/BarChart&gt;\n        );\n      case 'pie':\n        return (\n          &lt;PieChart&gt;\n            &lt;Pie\n              data={chartData}\n              dataKey=\"value\"\n              nameKey=\"name\"\n              label={({ percent }) =&gt; `${(percent * 100).toFixed(0)}%`}\n            &gt;\n              {chartData.map((_, index) =&gt; (\n                &lt;Cell key={index} fill={COLORS[index % COLORS.length]} /&gt;\n              ))}\n            &lt;/Pie&gt;\n            &lt;Tooltip /&gt;\n            &lt;Legend /&gt;\n          &lt;/PieChart&gt;\n        );\n      case 'area':\n        return (\n          &lt;AreaChart data={chartData}&gt;\n            &lt;defs&gt;\n              &lt;linearGradient id=\"colorValue\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\"&gt;\n                &lt;stop offset=\"5%\" stopColor=\"var(--color-chart-1)\" stopOpacity={0.8} /&gt;\n                &lt;stop offset=\"95%\" stopColor=\"var(--color-chart-1)\" stopOpacity={0} /&gt;\n              &lt;/linearGradient&gt;\n            &lt;/defs&gt;\n            &lt;CartesianGrid strokeDasharray=\"3 3\" /&gt;\n            &lt;XAxis dataKey=\"name\" /&gt;\n            &lt;YAxis /&gt;\n            &lt;Tooltip /&gt;\n            &lt;Area\n              type=\"monotone\"\n              dataKey=\"value\"\n              stroke=\"var(--color-chart-1)\"\n              fillOpacity={1}\n              fill=\"url(#colorValue)\"\n            /&gt;\n          &lt;/AreaChart&gt;\n        );\n    }\n  };\n\n  return (\n    &lt;Card&gt;\n      &lt;CardHeader&gt;\n        &lt;CardTitle&gt;{data.title}&lt;/CardTitle&gt;\n        {data.description &amp;&amp; (\n          &lt;CardDescription&gt;{data.description}&lt;/CardDescription&gt;\n        )}\n      &lt;/CardHeader&gt;\n      &lt;CardContent&gt;\n        &lt;ResponsiveContainer width=\"100%\" height={300}&gt;\n          {renderChart()}\n        &lt;/ResponsiveContainer&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre> <p>Supported Chart Types:</p> Type Description <code>line</code> Line chart for trends over time <code>bar</code> Bar chart for comparisons <code>pie</code> Pie chart for proportions <code>area</code> Area chart with gradient fill"},{"location":"modules/rendering-blocks/#codecontent","title":"CodeContent","text":"<p>Location: <code>src/components/blocks/CodeContent.tsx</code></p> <p>Renders syntax-highlighted code using Shiki.</p> <pre><code>interface CodeContentProps {\n  data: CodeContentData;\n}\n\nexport function CodeContent({ data }: CodeContentProps) {\n  const normalizedLanguage = normalizeLanguage(data.language);\n\n  return (\n    &lt;Card className=\"overflow-hidden\"&gt;\n      &lt;CardHeader className=\"flex flex-row items-center justify-between py-2 px-4\"&gt;\n        &lt;div className=\"flex items-center gap-2\"&gt;\n          {data.filename &amp;&amp; (\n            &lt;span className=\"text-sm font-mono\"&gt;{data.filename}&lt;/span&gt;\n          )}\n          &lt;Badge variant=\"secondary\"&gt;{normalizedLanguage}&lt;/Badge&gt;\n        &lt;/div&gt;\n        &lt;CopyButton text={data.code} /&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardContent className=\"p-0\"&gt;\n        &lt;CodeBlock\n          code={data.code}\n          language={normalizedLanguage}\n          showLineNumbers={data.showLineNumbers ?? true}\n        /&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}\n\n// Language normalization\nconst languageMap: Record&lt;string, string&gt; = {\n  js: 'javascript',\n  ts: 'typescript',\n  py: 'python',\n  sh: 'bash',\n  yml: 'yaml',\n  // ... more mappings\n};\n\nfunction normalizeLanguage(lang: string): string {\n  const normalized = lang.toLowerCase();\n  return languageMap[normalized] || normalized;\n}\n</code></pre> <p>Supported Languages (via Shiki):</p> <p>All major programming languages including JavaScript, TypeScript, Python, Go, Rust, Java, C++, and many more.</p>"},{"location":"modules/rendering-blocks/#cardcontent","title":"CardContent","text":"<p>Location: <code>src/components/blocks/CardContent.tsx</code></p> <p>Renders rich content cards with optional media and actions.</p> <pre><code>interface CardContentProps {\n  data: CardContentData;\n}\n\nexport function CardContent({ data }: CardContentProps) {\n  const hasMedia = !!data.media;\n\n  return (\n    &lt;Card className=\"overflow-hidden\"&gt;\n      &lt;div className={cn(\n        \"flex\",\n        hasMedia ? \"flex-col md:flex-row\" : \"flex-col\"\n      )}&gt;\n        {/* Media section */}\n        {hasMedia &amp;&amp; (\n          &lt;div className=\"md:w-1/2 shrink-0\"&gt;\n            {data.media.type === 'image' ? (\n              &lt;img\n                src={data.media.url}\n                alt={data.media.alt || data.title}\n                className=\"w-full h-full object-cover\"\n              /&gt;\n            ) : (\n              &lt;video\n                src={data.media.url}\n                controls\n                className=\"w-full h-full object-cover\"\n              /&gt;\n            )}\n          &lt;/div&gt;\n        )}\n\n        {/* Content section */}\n        &lt;div className=\"flex-1\"&gt;\n          &lt;CardHeader&gt;\n            &lt;CardTitle&gt;{data.title}&lt;/CardTitle&gt;\n            {data.description &amp;&amp; (\n              &lt;CardDescription&gt;{data.description}&lt;/CardDescription&gt;\n            )}\n          &lt;/CardHeader&gt;\n\n          {data.content &amp;&amp; (\n            &lt;CardContent&gt;\n              &lt;p&gt;{data.content}&lt;/p&gt;\n            &lt;/CardContent&gt;\n          )}\n\n          {data.actions &amp;&amp; data.actions.length &gt; 0 &amp;&amp; (\n            &lt;CardFooter className=\"flex gap-2\"&gt;\n              {data.actions.map((action, index) =&gt; (\n                &lt;Button\n                  key={index}\n                  variant={action.variant || 'default'}\n                  onClick={() =&gt; {\n                    toast.info(`Action: ${action.action}`);\n                    console.log('Action clicked:', action);\n                  }}\n                &gt;\n                  {action.label}\n                &lt;/Button&gt;\n              ))}\n            &lt;/CardFooter&gt;\n          )}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre> <p>Layout Modes:</p> Media Layout With image/video Horizontal (media left, content right) on desktop, stacked on mobile Without media Vertical stack"},{"location":"modules/rendering-blocks/#animation-system","title":"Animation System","text":"<p>Location: <code>src/lib/motion/variants.ts</code></p> <p>Blocks use Framer Motion for smooth animations:</p> <pre><code>// Fade in with upward motion\nexport const fadeInUp = {\n  hidden: { opacity: 0, y: 8 },\n  visible: {\n    opacity: 1,\n    y: 0,\n    transition: { duration: 0.3, ease: 'easeOut' },\n  },\n};\n\n// Staggered form fields\nexport const formFieldContainer = {\n  hidden: { opacity: 0 },\n  visible: {\n    opacity: 1,\n    transition: {\n      staggerChildren: 0.08,\n    },\n  },\n};\n\nexport const formField = {\n  hidden: { opacity: 0, x: -12 },\n  visible: {\n    opacity: 1,\n    x: 0,\n    transition: {\n      type: 'spring',\n      stiffness: 400,\n      damping: 30,\n    },\n  },\n};\n</code></pre>"},{"location":"modules/rendering-blocks/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>The complete flow from tool call to rendered block:</p> <pre><code>sequenceDiagram\n    participant AI as OpenAI\n    participant API as /api/chat\n    participant Stream\n    participant Message as ChatMessageItem\n    participant Dispatcher as ContentBlock\n    participant Block as *Content\n\n    AI-&gt;&gt;API: tool_call(generateChart, params)\n    API-&gt;&gt;API: Validate with Zod\n    API-&gt;&gt;API: Execute (pass-through)\n    API--&gt;&gt;Stream: tool-generateChart part\n\n    Stream--&gt;&gt;Message: Update message.parts\n    Message-&gt;&gt;Message: Detect tool- prefix\n    Message-&gt;&gt;Message: Check CONTENT_BLOCK_TOOLS\n\n    alt Is content block tool\n        Message-&gt;&gt;Dispatcher: &lt;ContentBlock content={output} /&gt;\n        Dispatcher-&gt;&gt;Dispatcher: Switch on content.type\n        Dispatcher-&gt;&gt;Block: &lt;ChartContent data={content} /&gt;\n        Block-&gt;&gt;Block: Render with Recharts\n    else Other tool\n        Message-&gt;&gt;Message: Render generic Tool component\n    end</code></pre>"},{"location":"modules/rendering-blocks/#extending-with-new-blocks","title":"Extending with New Blocks","text":"<p>To add a new block type, see the Adding AI Tools Tutorial.</p> <p>Quick checklist:</p> <ol> <li>[ ] Define Zod schema in <code>content-blocks.ts</code></li> <li>[ ] Add to <code>ContentBlock</code> union type</li> <li>[ ] Create tool in <code>tools.ts</code></li> <li>[ ] Create <code>*Content.tsx</code> component</li> <li>[ ] Add case in <code>ContentBlock.tsx</code> switch</li> <li>[ ] Add tool name to <code>CONTENT_BLOCK_TOOLS</code></li> <li>[ ] Update system prompt</li> </ol>"},{"location":"modules/rendering-blocks/#related-modules","title":"Related Modules","text":"<ul> <li>AI Integration - Tool definitions</li> <li>Chat System - Message handling</li> <li>Tutorials - Adding new tools</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Quick reference documentation for APIs and components.</p>"},{"location":"reference/#api-reference","title":"API Reference","text":"Endpoint Method Description <code>/api/chat</code> POST Streaming chat completions <code>/api/generate-title</code> POST Generate conversation titles"},{"location":"reference/#component-reference","title":"Component Reference","text":"Component Description ChatProvider Context provider for chat state ChatConversation Message list display ChatInput Input composer ContentBlock Tool result dispatcher"},{"location":"reference/#hook-reference","title":"Hook Reference","text":"Hook Description <code>useChat2()</code> Access chat context <code>useChatPersistence()</code> Message persistence <code>useConversations()</code> Conversation management <code>useTitleGeneration()</code> Title generation"},{"location":"reference/#type-reference","title":"Type Reference","text":"Type Location Description <code>ContentBlock</code> <code>src/types/content-blocks.ts</code> Tool output types <code>ConversationRecord</code> <code>src/lib/db/types.ts</code> Database conversation <code>MessageRecord</code> <code>src/lib/db/types.ts</code> Database message <code>UIMessage</code> <code>@ai-sdk/react</code> AI SDK message type"},{"location":"reference/api-endpoints/","title":"API Endpoints","text":"<p>Reference documentation for the application's API endpoints.</p>"},{"location":"reference/api-endpoints/#apichat","title":"/api/chat","text":"<p>Streaming chat completions endpoint using OpenAI models.</p>"},{"location":"reference/api-endpoints/#request","title":"Request","text":"<pre><code>POST /api/chat\nContent-Type: application/json\n</code></pre> <p>Body:</p> <pre><code>interface ChatRequest {\n  messages: UIMessage[];  // Array of chat messages\n  model: string;          // Model ID (e.g., \"gpt-5\", \"gpt-4o\")\n}\n</code></pre> <p>UIMessage Structure:</p> <pre><code>interface UIMessage {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  parts: ContentPart[];\n  createdAt?: Date;\n}\n\ntype ContentPart =\n  | { type: 'text'; text: string }\n  | { type: 'tool-call'; toolCallId: string; toolName: string; args: unknown }\n  | { type: 'tool-result'; toolCallId: string; result: unknown };\n</code></pre>"},{"location":"reference/api-endpoints/#response","title":"Response","text":"<p>Returns a streaming response using the AI SDK's UI message stream format.</p> <p>Stream Events:</p> Event Description Text chunk Partial text content Tool call AI requesting tool execution Tool result Tool execution result Done Stream complete"},{"location":"reference/api-endpoints/#example","title":"Example","text":"cURLJavaScript <pre><code>curl -X POST http://localhost:3000/api/chat \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"messages\": [\n      {\n        \"id\": \"msg-1\",\n        \"role\": \"user\",\n        \"parts\": [{ \"type\": \"text\", \"text\": \"Hello!\" }]\n      }\n    ],\n    \"model\": \"gpt-4o\"\n  }'\n</code></pre> <pre><code>const response = await fetch('/api/chat', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    messages: [\n      {\n        id: 'msg-1',\n        role: 'user',\n        parts: [{ type: 'text', text: 'Hello!' }],\n      },\n    ],\n    model: 'gpt-4o',\n  }),\n});\n\n// Handle streaming response\nconst reader = response.body?.getReader();\nwhile (true) {\n  const { done, value } = await reader.read();\n  if (done) break;\n  // Process chunk\n}\n</code></pre>"},{"location":"reference/api-endpoints/#error-responses","title":"Error Responses","text":"Status Description 400 Invalid request body 401 Missing or invalid API key 429 Rate limit exceeded 500 Internal server error"},{"location":"reference/api-endpoints/#implementation","title":"Implementation","text":"<p>Location: <code>src/app/api/chat/route.ts</code></p> <pre><code>import { streamText, convertToModelMessages, stepCountIs } from 'ai';\nimport { getModel } from '@/lib/ai/model';\nimport { chatTools } from '@/lib/ai/tools';\nimport { SYSTEM_PROMPT } from '@/lib/ai/prompts';\n\nexport async function POST(request: Request) {\n  const { messages, model: selectedModel } = await request.json();\n\n  const result = streamText({\n    model: getModel(selectedModel),\n    system: SYSTEM_PROMPT,\n    messages: convertToModelMessages(messages),\n    tools: chatTools,\n    stopWhen: stepCountIs(3),\n  });\n\n  return result.toUIMessageStreamResponse();\n}\n</code></pre>"},{"location":"reference/api-endpoints/#apigenerate-title","title":"/api/generate-title","text":"<p>Generate a title for a conversation based on the first user message.</p>"},{"location":"reference/api-endpoints/#request_1","title":"Request","text":"<pre><code>POST /api/generate-title\nContent-Type: application/json\n</code></pre> <p>Body:</p> <pre><code>interface TitleRequest {\n  userMessage: string;       // First user message text\n  conversationId: string;    // Conversation ID for tracking\n}\n</code></pre>"},{"location":"reference/api-endpoints/#response_1","title":"Response","text":"<pre><code>interface TitleResponse {\n  title: string;       // Generated title\n  useFallback: boolean; // Whether fallback was used\n}\n</code></pre>"},{"location":"reference/api-endpoints/#example_1","title":"Example","text":"cURLJavaScript <pre><code>curl -X POST http://localhost:3000/api/generate-title \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"userMessage\": \"How do I implement authentication in Next.js?\",\n    \"conversationId\": \"conv-123\"\n  }'\n</code></pre> <pre><code>const response = await fetch('/api/generate-title', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    userMessage: 'How do I implement authentication in Next.js?',\n    conversationId: 'conv-123',\n  }),\n});\n\nconst { title } = await response.json();\nconsole.log('Generated title:', title);\n// \"Next.js Authentication Implementation\"\n</code></pre>"},{"location":"reference/api-endpoints/#response-examples","title":"Response Examples","text":"<p>Success:</p> <pre><code>{\n  \"title\": \"Next.js Authentication Guide\",\n  \"useFallback\": false\n}\n</code></pre> <p>Fallback (on error):</p> <pre><code>{\n  \"title\": \"How do I implement authentication...\",\n  \"useFallback\": true\n}\n</code></pre>"},{"location":"reference/api-endpoints/#error-responses_1","title":"Error Responses","text":"Status Description 400 Missing userMessage or conversationId 500 Generation failed (falls back to truncated message)"},{"location":"reference/api-endpoints/#implementation_1","title":"Implementation","text":"<p>Location: <code>src/app/api/generate-title/route.ts</code></p> <pre><code>import { generateText } from 'ai';\nimport { openai } from '@ai-sdk/openai';\n\nexport async function POST(request: Request) {\n  const { userMessage, conversationId } = await request.json();\n\n  if (!userMessage || !conversationId) {\n    return Response.json(\n      { error: 'Missing required fields' },\n      { status: 400 }\n    );\n  }\n\n  try {\n    const result = await generateText({\n      model: openai('gpt-4o-mini'),\n      prompt: `Generate a short, descriptive title (max 50 chars) for a conversation that starts with: \"${userMessage}\"`,\n      maxTokens: 20,\n    });\n\n    return Response.json({\n      title: result.text.trim(),\n      useFallback: false,\n    });\n  } catch (error) {\n    // Fallback to truncated message\n    const fallback = userMessage.length &gt; 50\n      ? userMessage.slice(0, 47) + '...'\n      : userMessage;\n\n    return Response.json({\n      title: fallback,\n      useFallback: true,\n    });\n  }\n}\n</code></pre>"},{"location":"reference/api-endpoints/#custom-backend-configuration","title":"Custom Backend Configuration","text":"<p>The application supports connecting to a custom backend instead of using the built-in API routes.</p>"},{"location":"reference/api-endpoints/#environment-variable","title":"Environment Variable","text":"<pre><code>NEXT_PUBLIC_CHAT_API_URL=https://api.example.com\n</code></pre>"},{"location":"reference/api-endpoints/#url-resolution","title":"URL Resolution","text":"<p>When <code>NEXT_PUBLIC_CHAT_API_URL</code> is set:</p> Endpoint Resolved URL <code>chat</code> <code>https://api.example.com/chat</code> <code>generate-title</code> <code>https://api.example.com/generate-title</code>"},{"location":"reference/api-endpoints/#implementation_2","title":"Implementation","text":"<p>Location: <code>src/config.ts</code></p> <pre><code>export function getApiUrl(endpoint: 'chat' | 'generate-title'): string {\n  const baseUrl = process.env.NEXT_PUBLIC_CHAT_API_URL;\n\n  if (baseUrl) {\n    // External backend\n    return `${baseUrl}/${endpoint}`;\n  }\n\n  // Built-in API routes\n  return `/api/${endpoint}`;\n}\n</code></pre>"},{"location":"reference/api-endpoints/#backend-requirements","title":"Backend Requirements","text":"<p>If using a custom backend, ensure it:</p> <ol> <li>Accepts the same request format</li> <li>Returns streaming responses for <code>/chat</code></li> <li>Returns JSON for <code>/generate-title</code></li> <li>Handles CORS if on a different domain</li> </ol>"},{"location":"reference/components/","title":"Component Reference","text":"<p>Reference documentation for key React components and hooks.</p>"},{"location":"reference/components/#context-providers","title":"Context Providers","text":""},{"location":"reference/components/#chatprovider","title":"ChatProvider","text":"<p>Central context provider that orchestrates chat functionality.</p> <p>Location: <code>src/components/chat/ChatProvider.tsx</code></p> <p>Props:</p> <pre><code>interface ChatProviderProps {\n  children: React.ReactNode;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { ChatProvider } from '@/components/chat/ChatProvider';\n\nfunction App() {\n  return (\n    &lt;ChatProvider&gt;\n      &lt;YourApp /&gt;\n    &lt;/ChatProvider&gt;\n  );\n}\n</code></pre> <p>Provides: See useChat2() hook.</p>"},{"location":"reference/components/#hooks","title":"Hooks","text":""},{"location":"reference/components/#usechat2","title":"useChat2()","text":"<p>Access the chat context provided by <code>ChatProvider</code>.</p> <p>Location: <code>src/components/chat/ChatProvider.tsx</code></p> <p>Returns:</p> <pre><code>interface ChatContextType {\n  // Message state\n  messages: UIMessage[];\n  setMessages: Dispatch&lt;SetStateAction&lt;UIMessage[]&gt;&gt;;\n\n  // Actions\n  sendMessage: (text: string) =&gt; void;\n  clearMessages: () =&gt; void;\n  stop: () =&gt; void;\n\n  // Status\n  status: 'idle' | 'submitted' | 'streaming' | 'ready' | 'error';\n  isLoading: boolean;\n\n  // Model\n  selectedModel: string;\n  setSelectedModel: Dispatch&lt;SetStateAction&lt;string&gt;&gt;;\n\n  // Conversation\n  conversationId: string;\n  switchConversation: (id: string) =&gt; Promise&lt;void&gt;;\n  startNewConversation: () =&gt; Promise&lt;void&gt;;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { useChat2 } from '@/components/chat/ChatProvider';\n\nfunction ChatComponent() {\n  const {\n    messages,\n    sendMessage,\n    status,\n    isLoading,\n  } = useChat2();\n\n  return (\n    &lt;div&gt;\n      {messages.map(msg =&gt; /* render */)}\n      &lt;button\n        onClick={() =&gt; sendMessage('Hello')}\n        disabled={isLoading}\n      &gt;\n        Send\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#usechatpersistence","title":"useChatPersistence()","text":"<p>Manage message persistence with IndexedDB.</p> <p>Location: <code>src/hooks/useChatPersistence.ts</code></p> <p>Options:</p> <pre><code>interface UseChatPersistenceOptions {\n  conversationId?: string;\n  userId?: string;\n}\n</code></pre> <p>Returns:</p> <pre><code>interface UseChatPersistenceReturn {\n  conversationId: string;\n  storedMessages: UIMessage[];\n  isLoading: boolean;\n  isPersisted: boolean;\n  saveMessage: (message: UIMessage, fallbackTitle?: string) =&gt; Promise&lt;void&gt;;\n  updateMessage: (message: UIMessage) =&gt; Promise&lt;void&gt;;\n  createConversation: () =&gt; Promise&lt;string&gt;;\n  clearConversation: () =&gt; Promise&lt;void&gt;;\n  deleteConversation: (id?: string) =&gt; Promise&lt;void&gt;;\n  switchConversation: (id: string) =&gt; Promise&lt;UIMessage[]&gt;;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { useChatPersistence } from '@/hooks/useChatPersistence';\n\nfunction PersistenceExample() {\n  const {\n    conversationId,\n    storedMessages,\n    saveMessage,\n    switchConversation,\n  } = useChatPersistence();\n\n  const handleSave = async (message: UIMessage) =&gt; {\n    await saveMessage(message, 'Fallback Title');\n  };\n\n  return /* ... */;\n}\n</code></pre>"},{"location":"reference/components/#useconversations","title":"useConversations()","text":"<p>Manage the conversation list.</p> <p>Location: <code>src/hooks/useConversations.ts</code></p> <p>Options:</p> <pre><code>interface UseConversationsOptions {\n  userId?: string;\n  limit?: number;  // Default: 50\n}\n</code></pre> <p>Returns:</p> <pre><code>interface UseConversationsReturn {\n  conversations: ConversationRecord[];\n  isLoading: boolean;\n  updateTitle: (id: string, title: string) =&gt; Promise&lt;void&gt;;\n  deleteConversation: (id: string) =&gt; Promise&lt;void&gt;;\n  clearAllConversations: () =&gt; Promise&lt;void&gt;;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { useConversations } from '@/hooks/useConversations';\n\nfunction ConversationList() {\n  const {\n    conversations,\n    isLoading,\n    deleteConversation,\n  } = useConversations({ limit: 20 });\n\n  if (isLoading) return &lt;Loading /&gt;;\n\n  return (\n    &lt;ul&gt;\n      {conversations.map(conv =&gt; (\n        &lt;li key={conv.id}&gt;\n          {conv.title}\n          &lt;button onClick={() =&gt; deleteConversation(conv.id)}&gt;\n            Delete\n          &lt;/button&gt;\n        &lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#usetitlegeneration","title":"useTitleGeneration()","text":"<p>Generate conversation titles via LLM.</p> <p>Location: <code>src/hooks/useTitleGeneration.ts</code></p> <p>Options:</p> <pre><code>interface UseTitleGenerationOptions {\n  onTitleGenerated?: (conversationId: string, title: string) =&gt; void;\n  onError?: (error: Error) =&gt; void;\n}\n</code></pre> <p>Returns:</p> <pre><code>interface UseTitleGenerationReturn {\n  generateTitle: (conversationId: string, userMessage: string) =&gt; Promise&lt;void&gt;;\n  generateFallbackTitle: (userMessage: string) =&gt; string;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { useTitleGeneration } from '@/hooks/useTitleGeneration';\n\nfunction TitleGenerator() {\n  const { generateTitle, generateFallbackTitle } = useTitleGeneration({\n    onTitleGenerated: (id, title) =&gt; {\n      console.log(`Title for ${id}: ${title}`);\n    },\n  });\n\n  const handleGenerate = async () =&gt; {\n    await generateTitle('conv-123', 'How do I use React hooks?');\n  };\n\n  return /* ... */;\n}\n</code></pre>"},{"location":"reference/components/#chat-components","title":"Chat Components","text":""},{"location":"reference/components/#chatconversation","title":"ChatConversation","text":"<p>Displays the message list with auto-scroll.</p> <p>Location: <code>src/components/chat/ChatConversation.tsx</code></p> <p>Props: None (uses context)</p> <p>Usage:</p> <pre><code>import { ChatConversation } from '@/components/chat/ChatConversation';\n\nfunction ChatPage() {\n  return (\n    &lt;ChatProvider&gt;\n      &lt;ChatConversation /&gt;\n    &lt;/ChatProvider&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#chatmessageitem","title":"ChatMessageItem","text":"<p>Renders an individual message with text, tools, and reasoning.</p> <p>Location: <code>src/components/chat/ChatMessageItem.tsx</code></p> <p>Props:</p> <pre><code>interface ChatMessageItemProps {\n  message: UIMessage;\n  isStreaming?: boolean;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { ChatMessageItem } from '@/components/chat/ChatMessageItem';\n\nfunction MessageList({ messages }) {\n  return (\n    &lt;div&gt;\n      {messages.map((msg, i) =&gt; (\n        &lt;ChatMessageItem\n          key={msg.id}\n          message={msg}\n          isStreaming={i === messages.length - 1}\n        /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#chatinput","title":"ChatInput","text":"<p>Input composer with model selector.</p> <p>Location: <code>src/components/chat/ChatInput.tsx</code></p> <p>Props:</p> <pre><code>interface ChatInputProps {\n  isFixed?: boolean;        // Fixed position at bottom\n  placeholder?: string;     // Input placeholder\n}\n</code></pre> <p>Usage:</p> <pre><code>import { ChatInput } from '@/components/chat/ChatInput';\n\nfunction ChatPage() {\n  return (\n    &lt;ChatProvider&gt;\n      &lt;ChatConversation /&gt;\n      &lt;ChatInput isFixed placeholder=\"Type a message...\" /&gt;\n    &lt;/ChatProvider&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#block-components","title":"Block Components","text":""},{"location":"reference/components/#contentblock","title":"ContentBlock","text":"<p>Dispatcher that routes tool outputs to specific renderers.</p> <p>Location: <code>src/components/blocks/ContentBlock.tsx</code></p> <p>Props:</p> <pre><code>interface ContentBlockProps {\n  content: ContentBlock;  // Discriminated union type\n  messageId: string;\n}\n</code></pre> <p>Usage:</p> <pre><code>import { ContentBlock } from '@/components/blocks/ContentBlock';\n\nfunction ToolOutput({ toolOutput, messageId }) {\n  return (\n    &lt;ContentBlock\n      content={toolOutput}\n      messageId={messageId}\n    /&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#formcontent","title":"FormContent","text":"<p>Renders interactive forms.</p> <p>Location: <code>src/components/blocks/FormContent.tsx</code></p> <p>Props:</p> <pre><code>interface FormContentProps {\n  data: FormContentData;\n  messageId: string;\n}\n</code></pre> <p>FormContentData:</p> <pre><code>interface FormContentData {\n  type: \"form\";\n  title: string;\n  description?: string;\n  fields: FormField[];\n  submitLabel?: string;\n}\n\ninterface FormField {\n  name: string;\n  label: string;\n  type: \"text\" | \"textarea\" | \"email\" | \"number\" |\n        \"select\" | \"checkbox\" | \"radio\" | \"date\" |\n        \"slider\" | \"file\";\n  placeholder?: string;\n  required?: boolean;\n  options?: string[];  // For select, radio\n  min?: number;        // For slider\n  max?: number;\n  step?: number;\n}\n</code></pre>"},{"location":"reference/components/#chartcontent","title":"ChartContent","text":"<p>Renders data visualizations.</p> <p>Location: <code>src/components/blocks/ChartContent.tsx</code></p> <p>Props:</p> <pre><code>interface ChartContentProps {\n  data: ChartContentData;\n}\n</code></pre> <p>ChartContentData:</p> <pre><code>interface ChartContentData {\n  type: \"chart\";\n  chartType: \"line\" | \"bar\" | \"pie\" | \"area\";\n  title: string;\n  description?: string;\n  data: Array&lt;{\n    label: string;\n    value: number;\n  }&gt;;\n}\n</code></pre>"},{"location":"reference/components/#codecontent","title":"CodeContent","text":"<p>Renders syntax-highlighted code.</p> <p>Location: <code>src/components/blocks/CodeContent.tsx</code></p> <p>Props:</p> <pre><code>interface CodeContentProps {\n  data: CodeContentData;\n}\n</code></pre> <p>CodeContentData:</p> <pre><code>interface CodeContentData {\n  type: \"code\";\n  language: string;\n  filename?: string;\n  code: string;\n  editable?: boolean;\n  showLineNumbers?: boolean;\n}\n</code></pre>"},{"location":"reference/components/#cardcontent","title":"CardContent","text":"<p>Renders rich content cards.</p> <p>Location: <code>src/components/blocks/CardContent.tsx</code></p> <p>Props:</p> <pre><code>interface CardContentProps {\n  data: CardContentData;\n}\n</code></pre> <p>CardContentData:</p> <pre><code>interface CardContentData {\n  type: \"card\";\n  title: string;\n  description?: string;\n  content?: string;\n  media?: {\n    type: \"image\" | \"video\";\n    url: string;\n    alt?: string;\n  };\n  actions?: Array&lt;{\n    label: string;\n    action: string;\n    variant?: \"default\" | \"secondary\" | \"destructive\" | \"outline\";\n  }&gt;;\n}\n</code></pre>"},{"location":"reference/components/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/components/#cn","title":"cn()","text":"<p>Merge Tailwind CSS classes with conflict resolution.</p> <p>Location: <code>src/lib/utils.ts</code></p> <p>Signature:</p> <pre><code>function cn(...inputs: ClassValue[]): string\n</code></pre> <p>Usage:</p> <pre><code>import { cn } from '@/lib/utils';\n\nfunction Button({ className, variant }) {\n  return (\n    &lt;button\n      className={cn(\n        'px-4 py-2 rounded',\n        variant === 'primary' &amp;&amp; 'bg-blue-500',\n        variant === 'secondary' &amp;&amp; 'bg-gray-500',\n        className\n      )}\n    /&gt;\n  );\n}\n</code></pre>"},{"location":"reference/components/#getapiurl","title":"getApiUrl()","text":"<p>Get the correct API endpoint URL.</p> <p>Location: <code>src/config.ts</code></p> <p>Signature:</p> <pre><code>function getApiUrl(endpoint: 'chat' | 'generate-title'): string\n</code></pre> <p>Usage:</p> <pre><code>import { getApiUrl } from '@/config';\n\nconst chatUrl = getApiUrl('chat');\n// Returns \"/api/chat\" or \"https://custom-backend.com/chat\"\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common development tasks.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"Tutorial Difficulty Time Description Adding AI Tools Intermediate 30 min Add a new AI tool with custom rendering Extending Persistence Intermediate 20 min Add new database fields and migrations"},{"location":"tutorials/#learning-path","title":"Learning Path","text":""},{"location":"tutorials/#beginner","title":"Beginner","text":"<ol> <li>Read the Getting Started guide</li> <li>Explore the Project Structure</li> <li>Understand the Architecture</li> </ol>"},{"location":"tutorials/#intermediate","title":"Intermediate","text":"<ol> <li>Study the Chat System module</li> <li>Follow the Adding AI Tools tutorial</li> <li>Learn about Rendering Blocks</li> </ol>"},{"location":"tutorials/#advanced","title":"Advanced","text":"<ol> <li>Deep dive into Persistence</li> <li>Follow the Extending Persistence tutorial</li> <li>Explore the API Reference</li> </ol>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, ensure you have:</p> <ul> <li>[x] Set up your development environment</li> <li>[x] Run the application locally</li> <li>[x] Read the Architecture Overview</li> <li>[x] Familiarity with TypeScript and React</li> </ul>"},{"location":"tutorials/adding-ai-tools/","title":"Adding AI Tools","text":"<p>This tutorial walks through adding a new AI tool that generates and renders interactive content.</p>"},{"location":"tutorials/adding-ai-tools/#what-youll-build","title":"What You'll Build","text":"<p>We'll create a <code>generateTable</code> tool that displays data in a formatted table.</p> <p>Example prompt: \"Create a table showing quarterly sales data\"</p> <p>Result: An interactive table rendered in the chat.</p>"},{"location":"tutorials/adding-ai-tools/#prerequisites","title":"Prerequisites","text":"<ul> <li>Familiarity with TypeScript and Zod</li> <li>Understanding of React components</li> <li>Read the AI Integration module docs</li> </ul>"},{"location":"tutorials/adding-ai-tools/#step-1-define-the-type-schema","title":"Step 1: Define the Type Schema","text":"<p>First, add the Zod schema for your tool's data structure.</p> <p>File: <code>src/types/content-blocks.ts</code></p> <pre><code>import { z } from 'zod';\n\n// Add the new schema\nexport const TableContentDataSchema = z.object({\n  type: z.literal(\"table\"),\n  title: z.string().describe(\"Title for the table\"),\n  description: z.string().optional().describe(\"Optional description\"),\n  headers: z.array(z.string()).describe(\"Column headers\"),\n  rows: z.array(z.array(z.string())).describe(\"Table rows\"),\n  striped: z.boolean().optional().describe(\"Alternate row colors\"),\n});\n\nexport type TableContentData = z.infer&lt;typeof TableContentDataSchema&gt;;\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-2-update-the-union-type","title":"Step 2: Update the Union Type","text":"<p>Add the new type to the discriminated union.</p> <p>File: <code>src/types/content-blocks.ts</code></p> <pre><code>// Update the ContentBlock union\nexport type ContentBlock =\n  | FormContentData\n  | ChartContentData\n  | CodeContentData\n  | CardContentData\n  | TableContentData;  // Add this\n\n// Update the Zod schema union\nexport const ContentBlockSchema = z.discriminatedUnion(\"type\", [\n  FormContentDataSchema,\n  ChartContentDataSchema,\n  CodeContentDataSchema,\n  CardContentDataSchema,\n  TableContentDataSchema,  // Add this\n]);\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-3-create-the-tool","title":"Step 3: Create the Tool","text":"<p>Define the tool in the AI tools file.</p> <p>File: <code>src/lib/ai/tools.ts</code></p> <pre><code>import {\n  TableContentDataSchema,\n  type TableContentData,\n} from \"@/types/content-blocks\";\n\n// Add the new tool\nexport const generateTable = tool&lt;TableContentData, TableContentData&gt;({\n  description: \"Generate a data table for displaying structured information in rows and columns\",\n  inputSchema: TableContentDataSchema,\n  execute: async (input) =&gt; input, // Pass-through pattern\n});\n</code></pre> <p>Update the exports:</p> <pre><code>export const chatTools = {\n  generateForm,\n  generateChart,\n  generateCode,\n  generateCard,\n  generateTable,  // Add this\n  ...(config.ai.webSearch.enabled ? { webSearch } : {}),\n};\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-4-create-the-renderer","title":"Step 4: Create the Renderer","text":"<p>Create a React component to render the table.</p> <p>File: <code>src/components/blocks/TableContent.tsx</code></p> <pre><code>\"use client\";\n\nimport type { TableContentData } from \"@/types/content-blocks\";\nimport {\n  Card,\n  CardHeader,\n  CardTitle,\n  CardDescription,\n  CardContent,\n} from \"@/components/ui/card\";\nimport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableHead,\n  TableRow,\n  TableCell,\n} from \"@/components/ui/table\";\nimport { cn } from \"@/lib/utils\";\n\ninterface TableContentProps {\n  data: TableContentData;\n}\n\nexport function TableContent({ data }: TableContentProps) {\n  return (\n    &lt;Card className=\"overflow-hidden\"&gt;\n      &lt;CardHeader&gt;\n        &lt;CardTitle&gt;{data.title}&lt;/CardTitle&gt;\n        {data.description &amp;&amp; (\n          &lt;CardDescription&gt;{data.description}&lt;/CardDescription&gt;\n        )}\n      &lt;/CardHeader&gt;\n      &lt;CardContent className=\"p-0\"&gt;\n        &lt;div className=\"overflow-x-auto\"&gt;\n          &lt;Table&gt;\n            &lt;TableHeader&gt;\n              &lt;TableRow&gt;\n                {data.headers.map((header, index) =&gt; (\n                  &lt;TableHead key={index} className=\"font-semibold\"&gt;\n                    {header}\n                  &lt;/TableHead&gt;\n                ))}\n              &lt;/TableRow&gt;\n            &lt;/TableHeader&gt;\n            &lt;TableBody&gt;\n              {data.rows.map((row, rowIndex) =&gt; (\n                &lt;TableRow\n                  key={rowIndex}\n                  className={cn(\n                    data.striped &amp;&amp; rowIndex % 2 === 1 &amp;&amp; \"bg-muted/50\"\n                  )}\n                &gt;\n                  {row.map((cell, cellIndex) =&gt; (\n                    &lt;TableCell key={cellIndex}&gt;{cell}&lt;/TableCell&gt;\n                  ))}\n                &lt;/TableRow&gt;\n              ))}\n            &lt;/TableBody&gt;\n          &lt;/Table&gt;\n        &lt;/div&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-5-register-in-contentblock","title":"Step 5: Register in ContentBlock","text":"<p>Add the new block to the dispatcher.</p> <p>File: <code>src/components/blocks/ContentBlock.tsx</code></p> <pre><code>import { TableContent } from \"./TableContent\";  // Add import\n\nexport function ContentBlock({ content, messageId }: ContentBlockProps) {\n  const renderContent = () =&gt; {\n    switch (content.type) {\n      case \"form\":\n        return &lt;FormContent data={content} messageId={messageId} /&gt;;\n      case \"chart\":\n        return &lt;ChartContent data={content} /&gt;;\n      case \"code\":\n        return &lt;CodeContent data={content} /&gt;;\n      case \"card\":\n        return &lt;CardContent data={content} /&gt;;\n      case \"table\":                                    // Add this case\n        return &lt;TableContent data={content} /&gt;;\n      default:\n        return null;\n    }\n  };\n\n  // ... rest of component\n}\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-6-add-to-content-block-tools","title":"Step 6: Add to Content Block Tools","text":"<p>Register the tool name for detection.</p> <p>File: <code>src/components/chat/ChatMessageItem.tsx</code></p> <pre><code>const CONTENT_BLOCK_TOOLS = [\n  'generateForm',\n  'generateChart',\n  'generateCode',\n  'generateCard',\n  'generateTable',  // Add this\n];\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-7-update-system-prompt","title":"Step 7: Update System Prompt","text":"<p>Add guidance so the AI knows when to use the tool.</p> <p>File: <code>src/lib/ai/prompts.ts</code></p> <pre><code>export const SYSTEM_PROMPT = `You are a helpful assistant...\n\n### generateTable\nUSE WHEN: The user wants to DISPLAY data in a table format.\n- Trigger words: table, spreadsheet, grid, tabular data, rows and columns, comparison table, data table\n- Creates: Formatted tables with headers and rows\n- DO NOT use for: Data visualization (use generateChart), forms (use generateForm)\n\n## Decision Examples\n\n| User Request | Correct Tool |\n|--------------|--------------|\n| \"Create a contact form\" | generateForm |\n| \"Show sales data as a chart\" | generateChart |\n| \"Display quarterly results in a table\" | generateTable |\n| \"Create a comparison table for products\" | generateTable |\n...\n`;\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#step-8-test-your-tool","title":"Step 8: Test Your Tool","text":"<p>Start the dev server and test with prompts:</p> <pre><code>npm run dev\n</code></pre> <p>Test prompts:</p> <ol> <li>\"Create a table showing Q1-Q4 sales: Q1 $100k, Q2 $150k, Q3 $200k, Q4 $250k\"</li> <li>\"Make a comparison table for iPhone 15 vs Samsung S24\"</li> <li>\"Show a table of US presidents from 2000-2024\"</li> </ol>"},{"location":"tutorials/adding-ai-tools/#complete-file-changes","title":"Complete File Changes","text":"<p>Here's a summary of all files modified:</p> File Change <code>src/types/content-blocks.ts</code> Add schema, type, and union member <code>src/lib/ai/tools.ts</code> Add tool definition and export <code>src/components/blocks/TableContent.tsx</code> Create new file <code>src/components/blocks/ContentBlock.tsx</code> Add import and case <code>src/components/chat/ChatMessageItem.tsx</code> Add to CONTENT_BLOCK_TOOLS <code>src/lib/ai/prompts.ts</code> Add tool guidance"},{"location":"tutorials/adding-ai-tools/#advanced-adding-features","title":"Advanced: Adding Features","text":""},{"location":"tutorials/adding-ai-tools/#sortable-columns","title":"Sortable Columns","text":"<pre><code>// Add to schema\nsortable: z.boolean().optional(),\n\n// In TableContent.tsx\nconst [sortColumn, setSortColumn] = useState&lt;number | null&gt;(null);\nconst [sortDirection, setSortDirection] = useState&lt;'asc' | 'desc'&gt;('asc');\n\nconst sortedRows = useMemo(() =&gt; {\n  if (sortColumn === null || !data.sortable) return data.rows;\n\n  return [...data.rows].sort((a, b) =&gt; {\n    const comparison = a[sortColumn].localeCompare(b[sortColumn]);\n    return sortDirection === 'asc' ? comparison : -comparison;\n  });\n}, [data.rows, sortColumn, sortDirection, data.sortable]);\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#pagination","title":"Pagination","text":"<pre><code>// In TableContent.tsx\nconst [page, setPage] = useState(0);\nconst pageSize = 10;\n\nconst paginatedRows = data.rows.slice(\n  page * pageSize,\n  (page + 1) * pageSize\n);\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#export-to-csv","title":"Export to CSV","text":"<pre><code>const exportToCSV = () =&gt; {\n  const csv = [\n    data.headers.join(','),\n    ...data.rows.map(row =&gt; row.join(',')),\n  ].join('\\n');\n\n  const blob = new Blob([csv], { type: 'text/csv' });\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = `${data.title}.csv`;\n  a.click();\n};\n</code></pre>"},{"location":"tutorials/adding-ai-tools/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/adding-ai-tools/#tool-not-being-selected","title":"Tool not being selected","text":"<ul> <li>Check the system prompt includes clear trigger words</li> <li>Verify the tool name is in <code>chatTools</code> export</li> <li>Try more explicit prompts: \"Use the generateTable tool to...\"</li> </ul>"},{"location":"tutorials/adding-ai-tools/#type-errors","title":"Type errors","text":"<ul> <li>Ensure the Zod schema matches the TypeScript type</li> <li>Check that the type is in the <code>ContentBlock</code> union</li> <li>Verify the schema is in <code>ContentBlockSchema</code> union</li> </ul>"},{"location":"tutorials/adding-ai-tools/#block-not-rendering","title":"Block not rendering","text":"<ul> <li>Check the tool name is in <code>CONTENT_BLOCK_TOOLS</code></li> <li>Verify the case in <code>ContentBlock.tsx</code> switch statement</li> <li>Check browser console for errors</li> </ul>"},{"location":"tutorials/adding-ai-tools/#related-docs","title":"Related Docs","text":"<ul> <li>AI Integration - Tool architecture</li> <li>Rendering Blocks - Block patterns</li> <li>API Reference - API documentation</li> </ul>"},{"location":"tutorials/extending-persistence/","title":"Extending Persistence","text":"<p>This tutorial covers adding new fields to the database schema and writing migrations.</p>"},{"location":"tutorials/extending-persistence/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Adding new fields to existing tables</li> <li>Writing schema migrations</li> <li>Updating hooks to use new fields</li> <li>Testing persistence changes</li> </ul>"},{"location":"tutorials/extending-persistence/#prerequisites","title":"Prerequisites","text":"<ul> <li>Understanding of Persistence Module</li> <li>Familiarity with Dexie and IndexedDB</li> </ul>"},{"location":"tutorials/extending-persistence/#example-adding-tags-to-conversations","title":"Example: Adding Tags to Conversations","text":"<p>We'll add a <code>tags</code> field to conversations for categorization.</p>"},{"location":"tutorials/extending-persistence/#step-1-update-type-definitions","title":"Step 1: Update Type Definitions","text":"<p>First, add the new field to the TypeScript interface.</p> <p>File: <code>src/lib/db/types.ts</code></p> <pre><code>export interface ConversationRecord {\n  id: string;\n  title: string;\n  createdAt: Date;\n  updatedAt: Date;\n  userId?: string;\n  tags?: string[];  // Add this\n}\n</code></pre>"},{"location":"tutorials/extending-persistence/#step-2-update-database-schema","title":"Step 2: Update Database Schema","text":"<p>Increment the schema version and add a migration.</p> <p>File: <code>src/lib/db/schema.ts</code></p> <pre><code>import Dexie, { type Table } from 'dexie';\nimport type { ConversationRecord, MessageRecord } from './types';\n\nexport class ChatDatabase extends Dexie {\n  conversations!: Table&lt;ConversationRecord, string&gt;;\n  messages!: Table&lt;MessageRecord, number&gt;;\n\n  constructor() {\n    super('AIChatbotDB');\n\n    // Version 1 - Original schema\n    this.version(1).stores({\n      conversations: 'id, updatedAt, userId',\n      messages: '++id, conversationId, userId, createdAt',\n    });\n\n    // Version 2 - Add tags field with multi-entry index\n    this.version(2).stores({\n      conversations: 'id, updatedAt, userId, *tags',  // *tags = multi-entry index\n      messages: '++id, conversationId, userId, createdAt',\n    }).upgrade(tx =&gt; {\n      // Migration: Initialize tags for existing conversations\n      return tx.table('conversations').toCollection().modify(conv =&gt; {\n        conv.tags = [];\n      });\n    });\n  }\n}\n\nexport const db = new ChatDatabase();\n</code></pre> <p>Multi-entry Index</p> <p>The <code>*tags</code> syntax creates a multi-entry index, allowing efficient queries like \"find all conversations with tag X\".</p>"},{"location":"tutorials/extending-persistence/#step-3-update-usechatpersistence","title":"Step 3: Update useChatPersistence","text":"<p>Modify the hook to handle tags.</p> <p>File: <code>src/hooks/useChatPersistence.ts</code></p> <pre><code>// Update the saveMessage function\nconst saveMessage = useCallback(async (\n  message: UIMessage,\n  fallbackTitle?: string,\n  initialTags?: string[]  // Add parameter\n) =&gt; {\n  await db.transaction('rw', db.messages, db.conversations, async () =&gt; {\n    if (!isPersistedRef.current) {\n      const existingConv = await db.conversations.get(currentConversationId);\n      if (!existingConv) {\n        await db.conversations.put({\n          id: currentConversationId,\n          title: fallbackTitle || 'New Chat',\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          userId,\n          tags: initialTags || [],  // Initialize tags\n        });\n      }\n      isPersistedRef.current = true;\n    }\n    // ... rest of function\n  });\n}, [currentConversationId, userId]);\n</code></pre>"},{"location":"tutorials/extending-persistence/#step-4-add-tag-operations","title":"Step 4: Add Tag Operations","text":"<p>Add functions to manage tags.</p> <p>File: <code>src/hooks/useConversations.ts</code></p> <pre><code>export function useConversations(options?: UseConversationsOptions) {\n  // ... existing code\n\n  // Add tag to conversation\n  const addTag = useCallback(async (id: string, tag: string) =&gt; {\n    const conv = await db.conversations.get(id);\n    if (conv) {\n      const tags = conv.tags || [];\n      if (!tags.includes(tag)) {\n        await db.conversations.update(id, {\n          tags: [...tags, tag],\n          updatedAt: new Date(),\n        });\n      }\n    }\n  }, []);\n\n  // Remove tag from conversation\n  const removeTag = useCallback(async (id: string, tag: string) =&gt; {\n    const conv = await db.conversations.get(id);\n    if (conv &amp;&amp; conv.tags) {\n      await db.conversations.update(id, {\n        tags: conv.tags.filter(t =&gt; t !== tag),\n        updatedAt: new Date(),\n      });\n    }\n  }, []);\n\n  // Get conversations by tag\n  const getConversationsByTag = useCallback(async (tag: string) =&gt; {\n    return db.conversations\n      .where('tags')\n      .equals(tag)\n      .toArray();\n  }, []);\n\n  return {\n    conversations,\n    isLoading,\n    updateTitle,\n    deleteConversation,\n    clearAllConversations,\n    addTag,           // Add these\n    removeTag,\n    getConversationsByTag,\n  };\n}\n</code></pre>"},{"location":"tutorials/extending-persistence/#step-5-use-in-components","title":"Step 5: Use in Components","text":"<p>Now you can use tags in your UI.</p> <pre><code>import { useConversations } from '@/hooks/useConversations';\n\nfunction ConversationItem({ conversation }) {\n  const { addTag, removeTag } = useConversations();\n\n  const handleAddTag = async () =&gt; {\n    await addTag(conversation.id, 'important');\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{conversation.title}&lt;/span&gt;\n      &lt;div className=\"tags\"&gt;\n        {conversation.tags?.map(tag =&gt; (\n          &lt;Badge key={tag} onClick={() =&gt; removeTag(conversation.id, tag)}&gt;\n            {tag} \u00d7\n          &lt;/Badge&gt;\n        ))}\n        &lt;Button size=\"sm\" onClick={handleAddTag}&gt;\n          + Tag\n        &lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"tutorials/extending-persistence/#migration-best-practices","title":"Migration Best Practices","text":""},{"location":"tutorials/extending-persistence/#always-increment-version","title":"Always Increment Version","text":"<pre><code>// Wrong - modifying existing version\nthis.version(1).stores({\n  conversations: 'id, updatedAt, userId, *tags',  // Changed!\n});\n\n// Correct - new version\nthis.version(2).stores({\n  conversations: 'id, updatedAt, userId, *tags',\n});\n</code></pre>"},{"location":"tutorials/extending-persistence/#handle-missing-data","title":"Handle Missing Data","text":"<pre><code>// Defensive code in components\nconst tags = conversation.tags ?? [];\n\n// Or with default in query\nconst convs = await db.conversations.toArray();\nreturn convs.map(c =&gt; ({\n  ...c,\n  tags: c.tags ?? [],\n}));\n</code></pre>"},{"location":"tutorials/extending-persistence/#test-migrations","title":"Test Migrations","text":"<pre><code>// In development, test migration from scratch\nawait db.delete(); // Clear database\nawait db.open();   // Re-create with migrations\n\n// Or test upgrade path\nconst oldConv = await db.conversations.get('test-id');\nconsole.log('Tags after migration:', oldConv?.tags);\n</code></pre>"},{"location":"tutorials/extending-persistence/#example-adding-message-metadata","title":"Example: Adding Message Metadata","text":"<p>Here's another example: adding metadata to messages.</p>"},{"location":"tutorials/extending-persistence/#step-1-update-types","title":"Step 1: Update Types","text":"<pre><code>// src/lib/db/types.ts\nexport interface MessageRecord {\n  id?: number;\n  visibleId: string;\n  conversationId: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  userId?: string;\n  createdAt: Date;\n  metadata?: {                    // Add this\n    model?: string;               // Which model generated this\n    tokensUsed?: number;          // Token count\n    generationTime?: number;      // Time to generate (ms)\n  };\n}\n</code></pre>"},{"location":"tutorials/extending-persistence/#step-2-update-schema","title":"Step 2: Update Schema","text":"<pre><code>// src/lib/db/schema.ts\nthis.version(3).stores({\n  conversations: 'id, updatedAt, userId, *tags',\n  messages: '++id, conversationId, userId, createdAt, metadata.model',\n}).upgrade(tx =&gt; {\n  return tx.table('messages').toCollection().modify(msg =&gt; {\n    msg.metadata = {};\n  });\n});\n</code></pre>"},{"location":"tutorials/extending-persistence/#step-3-save-metadata","title":"Step 3: Save Metadata","text":"<pre><code>// In useChatPersistence.ts\nconst saveMessage = useCallback(async (\n  message: UIMessage,\n  fallbackTitle?: string,\n  metadata?: MessageMetadata\n) =&gt; {\n  // ...\n  await db.messages.add({\n    visibleId: message.id,\n    conversationId: currentConversationId,\n    role: message.role,\n    content: JSON.stringify(message.parts),\n    userId,\n    createdAt: new Date(),\n    metadata,  // Add metadata\n  });\n}, []);\n</code></pre>"},{"location":"tutorials/extending-persistence/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/extending-persistence/#upgradeerror-on-page-load","title":"\"UpgradeError\" on page load","text":"<p>The migration function has an error. Check:</p> <ul> <li>All fields referenced exist</li> <li>No syntax errors in upgrade function</li> <li>Version numbers are sequential</li> </ul> <pre><code>// Debug by logging\n.upgrade(tx =&gt; {\n  console.log('Running migration to version 2');\n  return tx.table('conversations').toCollection().modify(conv =&gt; {\n    console.log('Migrating conversation:', conv.id);\n    conv.tags = [];\n  });\n});\n</code></pre>"},{"location":"tutorials/extending-persistence/#data-not-persisting","title":"Data not persisting","text":"<p>Check if the new field is being passed:</p> <pre><code>// Add logging\nconsole.log('Saving with tags:', initialTags);\nawait db.conversations.put({\n  // ...\n  tags: initialTags || [],\n});\n\n// Verify after save\nconst saved = await db.conversations.get(id);\nconsole.log('Saved tags:', saved?.tags);\n</code></pre>"},{"location":"tutorials/extending-persistence/#index-not-working","title":"Index not working","text":"<p>Ensure the index is declared correctly:</p> <pre><code>// Wrong - no index for tags\nconversations: 'id, updatedAt, userId',\n\n// Correct - with multi-entry index\nconversations: 'id, updatedAt, userId, *tags',\n\n// Query using the index\nconst tagged = await db.conversations\n  .where('tags')\n  .equals('important')\n  .toArray();\n</code></pre>"},{"location":"tutorials/extending-persistence/#related-docs","title":"Related Docs","text":"<ul> <li>Persistence Module - Full persistence documentation</li> <li>Dexie.js Docs - Dexie documentation</li> <li>IndexedDB MDN - Browser API docs</li> </ul>"}]}